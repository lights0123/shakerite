<html class="offline">

<head>
	<title>T-Rex Game</title>
	<script type="text/javascript">
	const HIDDEN_CLASS = 'hidden';
	// Copyright (c) 2014 The Chromium Authors. All rights reserved.
	// Use of this source code is governed by a BSD-style license that can be
	// found in the LICENSE file.

	/**
	 * T-Rex runner.
	 * @param {string} outerContainerId Outer containing element id.
	 * @param {!Object=} opt_config
	 * @constructor
	 * @implements {EventListener}
	 * @export
	 */
	function Runner(outerContainerId, opt_config) {
		// Singleton
		if (Runner.instance_) {
			return Runner.instance_;
		}
		Runner.instance_ = this;

		this.outerContainerEl = document.querySelector(outerContainerId);
		this.containerEl = null;
		this.snackbarEl = null;
		// A div to intercept touch events. Only set while (playing && useTouch).
		this.touchController = null;

		this.config = opt_config || Runner.config;
		// Logical dimensions of the container.
		this.dimensions = Runner.defaultDimensions;

		this.canvas = null;
		this.canvasCtx = null;

		this.tRex = null;

		this.distanceMeter = null;
		this.distanceRan = 0;

		this.highestScore = 0;
		this.syncHighestScore = false;

		this.time = 0;
		this.runningTime = 0;
		this.msPerFrame = 1000 / FPS;
		this.currentSpeed = this.config.SPEED;

		this.obstacles = [];

		this.activated = false; // Whether the easter egg has been activated.
		this.playing = false; // Whether the game is currently in play state.
		this.crashed = false;
		this.paused = false;
		this.inverted = false;
		this.invertTimer = 0;
		this.resizeTimerId_ = null;

		this.playCount = 0;

		// Sound FX.
		this.audioBuffer = null;
		/** @type {Object} */
		this.soundFx = {};

		// Global web audio context for playing sounds.
		this.audioContext = null;

		// Images.
		this.images = {};
		this.imagesLoaded = 0;

		// Gamepad state.
		this.pollingGamepads = false;
		this.gamepadIndex = undefined;
		this.previousGamepad = null;

		this.loadImages();

		window['initializeEasterEggHighScore'] =
			this.initializeHighScore.bind(this);
	}

	/**
	 * Default game width.
	 * @const
	 */
	const DEFAULT_WIDTH = 600;

	/**
	 * Frames per second.
	 * @const
	 */
	const FPS = 60;

	/** @const */
	const IS_HIDPI = window.devicePixelRatio > 1;

	/** @const */
	const IS_IOS = /iPad|iPhone|iPod/.test(window.navigator.userAgent) && !window.MSStream;

	/** @const */
	const IS_MOBILE = /Android/.test(window.navigator.userAgent) || IS_IOS;

	/**
	 * Default game configuration.
	 */
	Runner.config = {
		ACCELERATION: 0.001,
		BG_CLOUD_SPEED: 0.2,
		BOTTOM_PAD: 10,
		// Scroll Y threshold at which the game can be activated.
		CANVAS_IN_VIEW_OFFSET: -10,
		CLEAR_TIME: 3000,
		CLOUD_FREQUENCY: 0.5,
		GAMEOVER_CLEAR_TIME: 750,
		GAP_COEFFICIENT: 0.6,
		GRAVITY: 0.6,
		INITIAL_JUMP_VELOCITY: 12,
		INVERT_FADE_DURATION: 12000,
		INVERT_DISTANCE: 700,
		MAX_BLINK_COUNT: 3,
		MAX_CLOUDS: 6,
		MAX_OBSTACLE_LENGTH: 3,
		MAX_OBSTACLE_DUPLICATION: 2,
		MAX_SPEED: 13,
		MIN_JUMP_HEIGHT: 35,
		MOBILE_SPEED_COEFFICIENT: 1.2,
		RESOURCE_TEMPLATE_ID: 'audio-resources',
		SPEED: 6,
		SPEED_DROP_COEFFICIENT: 3,
		ARCADE_MODE_INITIAL_TOP_POSITION: 35,
		ARCADE_MODE_TOP_POSITION_PERCENT: 0.1,
	};


	/**
	 * Default dimensions.
	 */
	Runner.defaultDimensions = {
		WIDTH: DEFAULT_WIDTH,
		HEIGHT: 150,
	};


	/**
	 * CSS class names.
	 * @enum {string}
	 */
	Runner.classes = {
		ARCADE_MODE: 'arcade-mode',
		CANVAS: 'runner-canvas',
		CONTAINER: 'runner-container',
		CRASHED: 'crashed',
		ICON: 'icon-offline',
		INVERTED: 'inverted',
		SNACKBAR: 'snackbar',
		SNACKBAR_SHOW: 'snackbar-show',
		TOUCH_CONTROLLER: 'controller',
	};


	/**
	 * Sprite definition layout of the spritesheet.
	 * @enum {Object}
	 */
	Runner.spriteDefinition = {
		LDPI: {
			CACTUS_LARGE: { x: 332, y: 2 },
			CACTUS_SMALL: { x: 228, y: 2 },
			CLOUD: { x: 86, y: 2 },
			HORIZON: { x: 2, y: 54 },
			MOON: { x: 484, y: 2 },
			PTERODACTYL: { x: 134, y: 2 },
			RESTART: { x: 2, y: 2 },
			TEXT_SPRITE: { x: 655, y: 2 },
			TREX: { x: 848, y: 2 },
			STAR: { x: 645, y: 2 },
		},
		HDPI: {
			CACTUS_LARGE: { x: 652, y: 2 },
			CACTUS_SMALL: { x: 446, y: 2 },
			CLOUD: { x: 166, y: 2 },
			HORIZON: { x: 2, y: 104 },
			MOON: { x: 954, y: 2 },
			PTERODACTYL: { x: 260, y: 2 },
			RESTART: { x: 2, y: 2 },
			TEXT_SPRITE: { x: 1294, y: 2 },
			TREX: { x: 1678, y: 2 },
			STAR: { x: 1276, y: 2 },
		},
	};


	/**
	 * Sound FX. Reference to the ID of the audio tag on interstitial page.
	 * @enum {string}
	 */
	Runner.sounds = {
		BUTTON_PRESS: 'offline-sound-press',
		HIT: 'offline-sound-hit',
		SCORE: 'offline-sound-reached',
	};


	/**
	 * Key code mapping.
	 * @enum {Object}
	 */
	Runner.keycodes = {
		JUMP: { '38': 1, '32': 1 },  // Up, spacebar
		DUCK: { '40': 1 },  // Down
		RESTART: { '13': 1 },  // Enter
	};


	/**
	 * Runner event names.
	 * @enum {string}
	 */
	Runner.events = {
		ANIM_END: 'webkitAnimationEnd',
		CLICK: 'click',
		KEYDOWN: 'keydown',
		KEYUP: 'keyup',
		POINTERDOWN: 'pointerdown',
		POINTERUP: 'pointerup',
		RESIZE: 'resize',
		TOUCHEND: 'touchend',
		TOUCHSTART: 'touchstart',
		VISIBILITY: 'visibilitychange',
		BLUR: 'blur',
		FOCUS: 'focus',
		LOAD: 'load',
		GAMEPADCONNECTED: 'gamepadconnected',
	};

	Runner.prototype = {
		/**
		 * Cache the appropriate image sprite from the page and get the sprite sheet
		 * definition.
		 */
		loadImages() {
			if (IS_HIDPI) {
				Runner.imageSprite = /** @type {HTMLImageElement} */
					(document.getElementById('offline-resources-2x'));
				this.spriteDef = Runner.spriteDefinition.HDPI;
			} else {
				Runner.imageSprite = /** @type {HTMLImageElement} */
					(document.getElementById('offline-resources-1x'));
				this.spriteDef = Runner.spriteDefinition.LDPI;
			}

			if (Runner.imageSprite.complete) {
				this.init();
			} else {
				// If the images are not yet loaded, add a listener.
				Runner.imageSprite.addEventListener(Runner.events.LOAD,
					this.init.bind(this));
			}
		},

		/**
		 * Load and decode base 64 encoded sounds.
		 */
		loadSounds() {
			let AudioContext = window.AudioContext || window.webkitAudioContext;
			this.audioContext = new AudioContext();

			const resourceTemplate =
				document.getElementById(this.config.RESOURCE_TEMPLATE_ID).content;

			for (const sound in Runner.sounds) {
				let soundSrc =
					resourceTemplate.getElementById(Runner.sounds[sound]).src;
				soundSrc = soundSrc.substr(soundSrc.indexOf(',') + 1);
				const buffer = decodeBase64ToArrayBuffer(soundSrc);

				// Async, so no guarantee of order in array.
				this.audioContext.decodeAudioData(buffer, function(index, audioData) {
					this.soundFx[index] = audioData;
				}.bind(this, sound));
			}
		},

		/**
		 * Sets the game speed. Adjust the speed accordingly if on a smaller screen.
		 * @param {number=} opt_speed
		 */
		setSpeed(opt_speed) {
			const speed = opt_speed || this.currentSpeed;

			// Reduce the speed on smaller mobile screens.
			if (this.dimensions.WIDTH < DEFAULT_WIDTH) {
				const mobileSpeed = speed * this.dimensions.WIDTH / DEFAULT_WIDTH *
					this.config.MOBILE_SPEED_COEFFICIENT;
				this.currentSpeed = mobileSpeed > speed ? speed : mobileSpeed;
			} else if (opt_speed) {
				this.currentSpeed = opt_speed;
			}
		},

		/**
		 * Game initialiser.
		 */
		init() {

			this.adjustDimensions();
			this.setSpeed();

			this.containerEl = document.createElement('div');
			this.containerEl.className = Runner.classes.CONTAINER;

			// Player canvas container.
			this.canvas = createCanvas(this.containerEl, this.dimensions.WIDTH,
				this.dimensions.HEIGHT);

			this.canvasCtx =
				/** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
			this.canvasCtx.fillStyle = '#f7f7f7';
			this.canvasCtx.fill();
			Runner.updateCanvasScaling(this.canvas);

			// Horizon contains clouds, obstacles and the ground.
			this.horizon = new Horizon(this.canvas, this.spriteDef, this.dimensions,
				this.config.GAP_COEFFICIENT);

			// Distance meter
			this.distanceMeter = new DistanceMeter(this.canvas,
				this.spriteDef.TEXT_SPRITE, this.dimensions.WIDTH);

			// Draw t-rex
			this.tRex = new Trex(this.canvas, this.spriteDef.TREX);

			this.outerContainerEl.appendChild(this.containerEl);

			this.startListening();
			this.update();

			window.addEventListener(Runner.events.RESIZE,
				this.debounceResize.bind(this));

			// Handle dark mode
			const darkModeMediaQuery =
				window.matchMedia('(prefers-color-scheme: dark)');
			this.isDarkMode = darkModeMediaQuery && darkModeMediaQuery.matches;
			darkModeMediaQuery.addListener((e) => {
				this.isDarkMode = e.matches;
			});
		},

		/**
		 * Create the touch controller. A div that covers whole screen.
		 */
		createTouchController() {
			this.touchController = document.createElement('div');
			this.touchController.className = Runner.classes.TOUCH_CONTROLLER;
			this.touchController.addEventListener(Runner.events.TOUCHSTART, this);
			this.touchController.addEventListener(Runner.events.TOUCHEND, this);
			this.outerContainerEl.appendChild(this.touchController);
		},

		/**
		 * Debounce the resize event.
		 */
		debounceResize() {
			if (!this.resizeTimerId_) {
				this.resizeTimerId_ =
					setInterval(this.adjustDimensions.bind(this), 250);
			}
		},

		/**
		 * Adjust game space dimensions on resize.
		 */
		adjustDimensions() {
			clearInterval(this.resizeTimerId_);
			this.resizeTimerId_ = null;

			const boxStyles = window.getComputedStyle(this.outerContainerEl);
			const padding = Number(boxStyles.paddingLeft.substr(0,
				boxStyles.paddingLeft.length - 2));

			this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2;
			if (this.isArcadeMode()) {
				this.dimensions.WIDTH = Math.min(DEFAULT_WIDTH, this.dimensions.WIDTH);
				if (this.activated) {
					this.setArcadeModeContainerScale();
				}
			}

			// Redraw the elements back onto the canvas.
			if (this.canvas) {
				this.canvas.width = this.dimensions.WIDTH;
				this.canvas.height = this.dimensions.HEIGHT;

				Runner.updateCanvasScaling(this.canvas);

				this.distanceMeter.calcXPos(this.dimensions.WIDTH);
				this.clearCanvas();
				this.horizon.update(0, 0, true);
				this.tRex.update(0);

				// Outer container and distance meter.
				if (this.playing || this.crashed || this.paused) {
					this.containerEl.style.width = this.dimensions.WIDTH + 'px';
					this.containerEl.style.height = this.dimensions.HEIGHT + 'px';
					this.distanceMeter.update(0, Math.ceil(this.distanceRan));
					this.stop();
				} else {
					this.tRex.draw(0, 0);
				}

				// Game over panel.
				if (this.crashed && this.gameOverPanel) {
					this.gameOverPanel.updateDimensions(this.dimensions.WIDTH);
					this.gameOverPanel.draw();
				}
			}
		},

		/**
		 * Play the game intro.
		 * Canvas container width expands out to the full width.
		 */
		playIntro() {
			if (!this.activated && !this.crashed) {
				this.playingIntro = true;
				this.tRex.playingIntro = true;

				// CSS animation definition.
				const keyframes = '@-webkit-keyframes intro { ' +
					'from { width:' + Trex.config.WIDTH + 'px }' +
					'to { width: ' + this.dimensions.WIDTH + 'px }' +
					'}';
				document.styleSheets[0].insertRule(keyframes, 0);

				this.containerEl.addEventListener(Runner.events.ANIM_END,
					this.startGame.bind(this));

				this.containerEl.style.webkitAnimation = 'intro .4s ease-out 1 both';
				this.containerEl.style.width = this.dimensions.WIDTH + 'px';

				this.setPlayStatus(true);
				this.activated = true;
			} else if (this.crashed) {
				this.restart();
			}
		},


		/**
		 * Update the game status to started.
		 */
		startGame() {
			if (this.isArcadeMode()) {
				this.setArcadeMode();
			}
			this.runningTime = 0;
			this.playingIntro = false;
			this.tRex.playingIntro = false;
			this.containerEl.style.webkitAnimation = '';
			this.playCount++;

			// Handle tabbing off the page. Pause the current game.
			document.addEventListener(Runner.events.VISIBILITY,
				this.onVisibilityChange.bind(this));

			window.addEventListener(Runner.events.BLUR,
				this.onVisibilityChange.bind(this));

			window.addEventListener(Runner.events.FOCUS,
				this.onVisibilityChange.bind(this));
		},

		clearCanvas() {
			this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH,
				this.dimensions.HEIGHT);
		},

		/**
		 * Checks whether the canvas area is in the viewport of the browser
		 * through the current scroll position.
		 * @return boolean.
		 */
		isCanvasInView() {
			return this.containerEl.getBoundingClientRect().top >
				Runner.config.CANVAS_IN_VIEW_OFFSET;
		},

		/**
		 * Update the game frame and schedules the next one.
		 */
		update() {
			this.updatePending = false;

			const now = getTimeStamp();
			let deltaTime = now - (this.time || now);

			this.time = now;

			if (this.playing) {
				this.clearCanvas();

				if (this.tRex.jumping) {
					this.tRex.updateJump(deltaTime);
				}

				this.runningTime += deltaTime;
				const hasObstacles = this.runningTime > this.config.CLEAR_TIME;

				// First jump triggers the intro.
				if (this.tRex.jumpCount === 1 && !this.playingIntro) {
					this.playIntro();
				}

				// The horizon doesn't move until the intro is over.
				if (this.playingIntro) {
					this.horizon.update(0, this.currentSpeed, hasObstacles);
				} else {
					const showNightMode = this.isDarkMode ^ this.inverted;
					deltaTime = !this.activated ? 0 : deltaTime;
					this.horizon.update(
						deltaTime, this.currentSpeed, hasObstacles, showNightMode);
				}

				// Check for collisions.
				const collision = hasObstacles &&
					checkForCollision(this.horizon.obstacles[0], this.tRex);

				if (!collision) {
					this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame;

					if (this.currentSpeed < this.config.MAX_SPEED) {
						this.currentSpeed += this.config.ACCELERATION;
					}
				} else {
					this.gameOver();
				}

				const playAchievementSound = this.distanceMeter.update(deltaTime,
					Math.ceil(this.distanceRan));

				if (playAchievementSound) {
					this.playSound(this.soundFx.SCORE);
				}

				// Night mode.
				if (this.invertTimer > this.config.INVERT_FADE_DURATION) {
					this.invertTimer = 0;
					this.invertTrigger = false;
					this.invert(false);
				} else if (this.invertTimer) {
					this.invertTimer += deltaTime;
				} else {
					const actualDistance =
						this.distanceMeter.getActualDistance(Math.ceil(this.distanceRan));

					if (actualDistance > 0) {
						this.invertTrigger = !(actualDistance %
							this.config.INVERT_DISTANCE);

						if (this.invertTrigger && this.invertTimer === 0) {
							this.invertTimer += deltaTime;
							this.invert(false);
						}
					}
				}
			}

			if (this.playing || (!this.activated &&
				this.tRex.blinkCount < Runner.config.MAX_BLINK_COUNT)) {
				this.tRex.update(deltaTime);
				this.scheduleNextUpdate();
			}
		},

		/**
		 * Event handler.
		 * @param {Event} e
		 */
		handleEvent(e) {
			return (function(evtType, events) {
				switch (evtType) {
					case events.KEYDOWN:
					case events.TOUCHSTART:
					case events.POINTERDOWN:
						this.onKeyDown(e);
						break;
					case events.KEYUP:
					case events.TOUCHEND:
					case events.POINTERUP:
						this.onKeyUp(e);
						break;
					case events.GAMEPADCONNECTED:
						this.onGamepadConnected(e);
						break;
				}
			}.bind(this))(e.type, Runner.events);
		},

		/**
		 * Bind relevant key / mouse / touch listeners.
		 */
		startListening() {
			// Keys.
			document.addEventListener(Runner.events.KEYDOWN, this);
			document.addEventListener(Runner.events.KEYUP, this);

			// Touch / pointer.
			this.containerEl.addEventListener(Runner.events.TOUCHSTART, this);
			document.addEventListener(Runner.events.POINTERDOWN, this);
			document.addEventListener(Runner.events.POINTERUP, this);

			if (this.isArcadeMode()) {
				// Gamepad
				window.addEventListener(Runner.events.GAMEPADCONNECTED, this);
			}
		},

		/**
		 * Remove all listeners.
		 */
		stopListening() {
			document.removeEventListener(Runner.events.KEYDOWN, this);
			document.removeEventListener(Runner.events.KEYUP, this);

			if (this.touchController) {
				this.touchController.removeEventListener(Runner.events.TOUCHSTART, this);
				this.touchController.removeEventListener(Runner.events.TOUCHEND, this);
			}

			this.containerEl.removeEventListener(Runner.events.TOUCHSTART, this);
			document.removeEventListener(Runner.events.POINTERDOWN, this);
			document.removeEventListener(Runner.events.POINTERUP, this);

			if (this.isArcadeMode()) {
				window.removeEventListener(Runner.events.GAMEPADCONNECTED, this);
			}
		},

		/**
		 * Process keydown.
		 * @param {Event} e
		 */
		onKeyDown(e) {
			// Prevent native page scrolling whilst tapping on mobile.
			if (IS_MOBILE && this.playing) {
				e.preventDefault();
			}

			if (this.isCanvasInView()) {
				if (!this.crashed && !this.paused) {
					if (Runner.keycodes.JUMP[e.keyCode] ||
						e.type === Runner.events.TOUCHSTART) {
						e.preventDefault();
						// Starting the game for the first time.
						if (!this.playing) {
							// Started by touch so create a touch controller.
							if (!this.touchController && e.type === Runner.events.TOUCHSTART) {
								this.createTouchController();
							}
							this.loadSounds();
							this.setPlayStatus(true);
							this.update();
							if (window.errorPageController) {
								errorPageController.trackEasterEgg();
							}
						}
						// Start jump.
						if (!this.tRex.jumping && !this.tRex.ducking) {
							this.playSound(this.soundFx.BUTTON_PRESS);
							this.tRex.startJump(this.currentSpeed);
						}
					} else if (this.playing && Runner.keycodes.DUCK[e.keyCode]) {
						e.preventDefault();
						if (this.tRex.jumping) {
							// Speed drop, activated only when jump key is not pressed.
							this.tRex.setSpeedDrop();
						} else if (!this.tRex.jumping && !this.tRex.ducking) {
							// Duck.
							this.tRex.setDuck(true);
						}
					}
					// iOS only triggers touchstart and no pointer events.
				} else if (
					IS_IOS && this.crashed && e.type === Runner.events.TOUCHSTART &&
					e.currentTarget === this.containerEl) {
					this.handleGameOverClicks(e);
				}
			}
		},

		/**
		 * Process key up.
		 * @param {Event} e
		 */
		onKeyUp(e) {
			const keyCode = String(e.keyCode);
			const isjumpKey = Runner.keycodes.JUMP[keyCode] ||
				e.type === Runner.events.TOUCHEND || e.type === Runner.events.POINTERUP;

			if (this.isRunning() && isjumpKey) {
				this.tRex.endJump();
			} else if (Runner.keycodes.DUCK[keyCode]) {
				this.tRex.speedDrop = false;
				this.tRex.setDuck(false);
			} else if (this.crashed) {
				// Check that enough time has elapsed before allowing jump key to restart.
				const deltaTime = getTimeStamp() - this.time;

				if (this.isCanvasInView() &&
					(Runner.keycodes.RESTART[keyCode] || this.isLeftClickOnCanvas(e) ||
						(deltaTime >= this.config.GAMEOVER_CLEAR_TIME &&
							Runner.keycodes.JUMP[keyCode]))) {
					this.handleGameOverClicks(e);
				}
			} else if (this.paused && isjumpKey) {
				// Reset the jump state
				this.tRex.reset();
				this.play();
			}
		},

		/**
		 * Process gamepad connected event.
		 * @param {Event} e
		 */
		onGamepadConnected(e) {
			if (!this.pollingGamepads) {
				this.pollGamepadState();
			}
		},

		/**
		 * rAF loop for gamepad polling.
		 */
		pollGamepadState() {
			const gamepads = navigator.getGamepads();
			this.pollActiveGamepad(gamepads);

			this.pollingGamepads = true;
			requestAnimationFrame(this.pollGamepadState.bind(this));
		},

		/**
		 * Polls for a gamepad with the jump button pressed. If one is found this
		 * becomes the "active" gamepad and all others are ignored.
		 * @param {!Array<Gamepad>} gamepads
		 */
		pollForActiveGamepad(gamepads) {
			for (let i = 0; i < gamepads.length; ++i) {
				if (gamepads[i] && gamepads[i].buttons.length > 0 &&
					gamepads[i].buttons[0].pressed) {
					this.gamepadIndex = i;
					this.pollActiveGamepad(gamepads);
					return;
				}
			}
		},

		/**
		 * Polls the chosen gamepad for button presses and generates KeyboardEvents
		 * to integrate with the rest of the game logic.
		 * @param {!Array<Gamepad>} gamepads
		 */
		pollActiveGamepad(gamepads) {
			if (this.gamepadIndex === undefined) {
				this.pollForActiveGamepad(gamepads);
				return;
			}

			const gamepad = gamepads[this.gamepadIndex];
			if (!gamepad) {
				this.gamepadIndex = undefined;
				this.pollForActiveGamepad(gamepads);
				return;
			}

			// The gamepad specification defines the typical mapping of physical buttons
			// to button indicies: https://w3c.github.io/gamepad/#remapping
			this.pollGamepadButton(gamepad, 0, 38);  // Jump
			if (gamepad.buttons.length >= 2) {
				this.pollGamepadButton(gamepad, 1, 40);  // Duck
			}
			if (gamepad.buttons.length >= 10) {
				this.pollGamepadButton(gamepad, 9, 13);  // Restart
			}

			this.previousGamepad = gamepad;
		},

		/**
		 * Generates a key event based on a gamepad button.
		 * @param {!Gamepad} gamepad
		 * @param {number} buttonIndex
		 * @param {number} keyCode
		 */
		pollGamepadButton(gamepad, buttonIndex, keyCode) {
			const state = gamepad.buttons[buttonIndex].pressed;
			let previousState = false;
			if (this.previousGamepad) {
				previousState = this.previousGamepad.buttons[buttonIndex].pressed;
			}
			// Generate key events on the rising and falling edge of a button press.
			if (state !== previousState) {
				const e = new KeyboardEvent(state ? Runner.events.KEYDOWN
					: Runner.events.KEYUP,
					{ keyCode: keyCode });
				document.dispatchEvent(e);
			}
		},

		/**
		 * Handle interactions on the game over screen state.
		 * A user is able to tap the high score twice to reset it.
		 * @param {Event} e
		 */
		handleGameOverClicks(e) {
			e.preventDefault();
			if (this.distanceMeter.hasClickedOnHighScore(e) && this.highestScore) {
				if (this.distanceMeter.isHighScoreFlashing()) {
					// Subsequent click, reset the high score.
					this.saveHighScore(0, true);
					this.distanceMeter.resetHighScore();
				} else {
					// First click, flash the high score.
					this.distanceMeter.startHighScoreFlashing();
				}
			} else {
				this.distanceMeter.cancelHighScoreFlashing();
				this.restart();
			}
		},

		/**
		 * Returns whether the event was a left click on canvas.
		 * On Windows right click is registered as a click.
		 * @param {Event} e
		 * @return {boolean}
		 */
		isLeftClickOnCanvas(e) {
			return e.button != null && e.button < 2 &&
				e.type === Runner.events.POINTERUP && e.target === this.canvas;
		},

		/**
		 * RequestAnimationFrame wrapper.
		 */
		scheduleNextUpdate() {
			if (!this.updatePending) {
				this.updatePending = true;
				this.raqId = requestAnimationFrame(this.update.bind(this));
			}
		},

		/**
		 * Whether the game is running.
		 * @return {boolean}
		 */
		isRunning() {
			return !!this.raqId;
		},

		/**
		 * Set the initial high score as stored in the user's profile.
		 * @param {number} highScore
		 */
		initializeHighScore(highScore) {
			this.syncHighestScore = true;
			highScore = Math.ceil(highScore);
			if (highScore < this.highestScore) {
				if (window.errorPageController) {
					errorPageController.updateEasterEggHighScore(this.highestScore);
				}
				return;
			}
			this.highestScore = highScore;
			this.distanceMeter.setHighScore(this.highestScore);
		},

		/**
		 * Sets the current high score and saves to the profile if available.
		 * @param {number} distanceRan Total distance ran.
		 * @param {boolean=} opt_resetScore Whether to reset the score.
		 */
		saveHighScore(distanceRan, opt_resetScore) {
			this.highestScore = Math.ceil(distanceRan);
			this.distanceMeter.setHighScore(this.highestScore);

			// Store the new high score in the profile.
			if (this.syncHighestScore && window.errorPageController) {
				if (opt_resetScore) {
					errorPageController.resetEasterEggHighScore();
				} else {
					errorPageController.updateEasterEggHighScore(this.highestScore);
				}
			}
		},

		/**
		 * Game over state.
		 */
		gameOver() {
			this.playSound(this.soundFx.HIT);
			vibrate(200);

			this.stop();
			this.crashed = true;
			this.distanceMeter.achievement = false;

			this.tRex.update(100, Trex.status.CRASHED);

			// Game over panel.
			if (!this.gameOverPanel) {
				if (this.canvas) {
					this.gameOverPanel = new GameOverPanel(this.canvas,
						this.spriteDef.TEXT_SPRITE, this.spriteDef.RESTART,
						this.dimensions);
				}
			} else {
				this.gameOverPanel.draw();
			}

			// Update the high score.
			if (this.distanceRan > this.highestScore) {
				this.saveHighScore(this.distanceRan);
			}

			// Reset the time clock.
			this.time = getTimeStamp();
		},

		stop() {
			this.setPlayStatus(false);
			this.paused = true;
			cancelAnimationFrame(this.raqId);
			this.raqId = 0;
		},

		play() {
			if (!this.crashed) {
				this.setPlayStatus(true);
				this.paused = false;
				this.tRex.update(0, Trex.status.RUNNING);
				this.time = getTimeStamp();
				this.update();
			}
		},

		restart() {
			if (!this.raqId) {
				this.playCount++;
				this.runningTime = 0;
				this.setPlayStatus(true);
				this.paused = false;
				this.crashed = false;
				this.distanceRan = 0;
				this.setSpeed(this.config.SPEED);
				this.time = getTimeStamp();
				this.containerEl.classList.remove(Runner.classes.CRASHED);
				this.clearCanvas();
				this.distanceMeter.reset();
				this.horizon.reset();
				this.tRex.reset();
				this.playSound(this.soundFx.BUTTON_PRESS);
				this.invert(true);
				this.bdayFlashTimer = null;
				this.update();
			}
		},

		setPlayStatus(isPlaying) {
			if (this.touchController) {
				this.touchController.classList.toggle(HIDDEN_CLASS, !isPlaying);
			}
			this.playing = isPlaying;
		},

		/**
		 * Whether the game should go into arcade mode.
		 * @return {boolean}
		 */
		isArcadeMode() {
			return true;
		},

		/**
		 * Hides offline messaging for a fullscreen game only experience.
		 */
		setArcadeMode() {
			document.body.classList.add(Runner.classes.ARCADE_MODE);
			this.setArcadeModeContainerScale();
		},

		/**
		 * Sets the scaling for arcade mode.
		 */
		setArcadeModeContainerScale() {
			const windowHeight = window.innerHeight;
			const scaleHeight = windowHeight / this.dimensions.HEIGHT;
			const scaleWidth = window.innerWidth / this.dimensions.WIDTH;
			const scale = Math.max(1, Math.min(scaleHeight, scaleWidth));
			const scaledCanvasHeight = this.dimensions.HEIGHT * scale;
			// Positions the game container at 10% of the available vertical window
			// height minus the game container height.
			const translateY = Math.ceil(Math.max(0, (windowHeight - scaledCanvasHeight -
				Runner.config.ARCADE_MODE_INITIAL_TOP_POSITION) *
				Runner.config.ARCADE_MODE_TOP_POSITION_PERCENT)) *
				window.devicePixelRatio;
			this.containerEl.style.transform = 'scale(' + scale + ') translateY(' +
				translateY + 'px)';
		},

		/**
		 * Pause the game if the tab is not in focus.
		 */
		onVisibilityChange(e) {
			if (document.hidden || document.webkitHidden || e.type === 'blur' ||
				document.visibilityState !== 'visible') {
				this.stop();
			} else if (!this.crashed) {
				this.tRex.reset();
				this.play();
			}
		},

		/**
		 * Play a sound.
		 * @param {AudioBuffer} soundBuffer
		 */
		playSound(soundBuffer) {
			if (soundBuffer) {
				const sourceNode = this.audioContext.createBufferSource();
				sourceNode.buffer = soundBuffer;
				sourceNode.connect(this.audioContext.destination);
				sourceNode.start(0);
			}
		},

		/**
		 * Inverts the current page / canvas colors.
		 * @param {boolean} reset Whether to reset colors.
		 */
		invert(reset) {
			const htmlEl = document.firstElementChild;

			if (reset) {
				htmlEl.classList.toggle(Runner.classes.INVERTED,
					false);
				this.invertTimer = 0;
				this.inverted = false;
			} else {
				this.inverted = htmlEl.classList.toggle(
					Runner.classes.INVERTED, this.invertTrigger);
			}
		},
	};


	/**
	 * Updates the canvas size taking into
	 * account the backing store pixel ratio and
	 * the device pixel ratio.
	 *
	 * See article by Paul Lewis:
	 * http://www.html5rocks.com/en/tutorials/canvas/hidpi/
	 *
	 * @param {HTMLCanvasElement} canvas
	 * @param {number=} opt_width
	 * @param {number=} opt_height
	 * @return {boolean} Whether the canvas was scaled.
	 */
	Runner.updateCanvasScaling = function(canvas, opt_width, opt_height) {
		const context =
			/** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));

		// Query the various pixel ratios
		const devicePixelRatio = Math.floor(window.devicePixelRatio) || 1;
		/** @suppress {missingProperties} */
		const backingStoreRatio =
			Math.floor(context.webkitBackingStorePixelRatio) || 1;
		const ratio = devicePixelRatio / backingStoreRatio;

		// Upscale the canvas if the two ratios don't match
		if (devicePixelRatio !== backingStoreRatio) {
			const oldWidth = opt_width || canvas.width;
			const oldHeight = opt_height || canvas.height;

			canvas.width = oldWidth * ratio;
			canvas.height = oldHeight * ratio;

			canvas.style.width = oldWidth + 'px';
			canvas.style.height = oldHeight + 'px';

			// Scale the context to counter the fact that we've manually scaled
			// our canvas element.
			context.scale(ratio, ratio);
			return true;
		} else if (devicePixelRatio === 1) {
			// Reset the canvas width / height. Fixes scaling bug when the page is
			// zoomed and the devicePixelRatio changes accordingly.
			canvas.style.width = canvas.width + 'px';
			canvas.style.height = canvas.height + 'px';
		}
		return false;
	};


	/**
	 * Get random number.
	 * @param {number} min
	 * @param {number} max
	 */
	function getRandomNum(min, max) {
		return Math.floor(Math.random() * (max - min + 1)) + min;
	}


	/**
	 * Vibrate on mobile devices.
	 * @param {number} duration Duration of the vibration in milliseconds.
	 */
	function vibrate(duration) {
		if (IS_MOBILE && window.navigator.vibrate) {
			window.navigator.vibrate(duration);
		}
	}


	/**
	 * Create canvas element.
	 * @param {Element} container Element to append canvas to.
	 * @param {number} width
	 * @param {number} height
	 * @param {string=} opt_classname
	 * @return {HTMLCanvasElement}
	 */
	function createCanvas(container, width, height, opt_classname) {
		const canvas =
			/** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));
		canvas.className = opt_classname ? Runner.classes.CANVAS + ' ' +
			opt_classname : Runner.classes.CANVAS;
		canvas.width = width;
		canvas.height = height;
		container.appendChild(canvas);

		return canvas;
	}


	/**
	 * Decodes the base 64 audio to ArrayBuffer used by Web Audio.
	 * @param {string} base64String
	 */
	function decodeBase64ToArrayBuffer(base64String) {
		const len = (base64String.length / 4) * 3;
		const str = atob(base64String);
		const arrayBuffer = new ArrayBuffer(len);
		const bytes = new Uint8Array(arrayBuffer);

		for (let i = 0; i < len; i++) {
			bytes[i] = str.charCodeAt(i);
		}
		return bytes.buffer;
	}


	/**
	 * Return the current timestamp.
	 * @return {number}
	 */
	function getTimeStamp() {
		return IS_IOS ? new Date().getTime() : performance.now();
	}


	//******************************************************************************


	/**
	 * Game over panel.
	 * @param {!HTMLCanvasElement} canvas
	 * @param {Object} textImgPos
	 * @param {Object} restartImgPos
	 * @param {!Object} dimensions Canvas dimensions.
	 * @constructor
	 */
	function GameOverPanel(canvas, textImgPos, restartImgPos, dimensions) {
		this.canvas = canvas;
		this.canvasCtx =
			/** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
		this.canvasDimensions = dimensions;
		this.textImgPos = textImgPos;
		this.restartImgPos = restartImgPos;
		this.draw();
	}


	/**
	 * Dimensions used in the panel.
	 * @enum {number}
	 */
	GameOverPanel.dimensions = {
		TEXT_X: 0,
		TEXT_Y: 13,
		TEXT_WIDTH: 191,
		TEXT_HEIGHT: 11,
		RESTART_WIDTH: 36,
		RESTART_HEIGHT: 32,
	};


	GameOverPanel.prototype = {
		/**
		 * Update the panel dimensions.
		 * @param {number} width New canvas width.
		 * @param {number} opt_height Optional new canvas height.
		 */
		updateDimensions(width, opt_height) {
			this.canvasDimensions.WIDTH = width;
			if (opt_height) {
				this.canvasDimensions.HEIGHT = opt_height;
			}
		},

		/**
		 * Draw the panel.
		 */
		draw() {
			const dimensions = GameOverPanel.dimensions;

			const centerX = this.canvasDimensions.WIDTH / 2;

			// Game over text.
			let textSourceX = dimensions.TEXT_X;
			let textSourceY = dimensions.TEXT_Y;
			let textSourceWidth = dimensions.TEXT_WIDTH;
			let textSourceHeight = dimensions.TEXT_HEIGHT;

			const textTargetX = Math.round(centerX - (dimensions.TEXT_WIDTH / 2));
			const textTargetY = Math.round((this.canvasDimensions.HEIGHT - 25) / 3);
			const textTargetWidth = dimensions.TEXT_WIDTH;
			const textTargetHeight = dimensions.TEXT_HEIGHT;

			let restartSourceWidth = dimensions.RESTART_WIDTH;
			let restartSourceHeight = dimensions.RESTART_HEIGHT;
			const restartTargetX = centerX - (dimensions.RESTART_WIDTH / 2);
			const restartTargetY = this.canvasDimensions.HEIGHT / 2;

			if (IS_HIDPI) {
				textSourceY *= 2;
				textSourceX *= 2;
				textSourceWidth *= 2;
				textSourceHeight *= 2;
				restartSourceWidth *= 2;
				restartSourceHeight *= 2;
			}

			textSourceX += this.textImgPos.x;
			textSourceY += this.textImgPos.y;

			// Game over text from sprite.
			this.canvasCtx.drawImage(Runner.imageSprite,
				textSourceX, textSourceY, textSourceWidth, textSourceHeight,
				textTargetX, textTargetY, textTargetWidth, textTargetHeight);

			// Restart button.
			this.canvasCtx.drawImage(Runner.imageSprite,
				this.restartImgPos.x, this.restartImgPos.y,
				restartSourceWidth, restartSourceHeight,
				restartTargetX, restartTargetY, dimensions.RESTART_WIDTH,
				dimensions.RESTART_HEIGHT);
		},
	};


	//******************************************************************************

	/**
	 * Check for a collision.
	 * @param {!Obstacle} obstacle
	 * @param {!Trex} tRex T-rex object.
	 * @param {CanvasRenderingContext2D=} opt_canvasCtx Optional canvas context for
	 *    drawing collision boxes.
	 * @return {Array<CollisionBox>|undefined}
	 */
	function checkForCollision(obstacle, tRex, opt_canvasCtx) {
		const obstacleBoxXPos = Runner.defaultDimensions.WIDTH + obstacle.xPos;

		// Adjustments are made to the bounding box as there is a 1 pixel white
		// border around the t-rex and obstacles.
		const tRexBox = new CollisionBox(
			tRex.xPos + 1,
			tRex.yPos + 1,
			tRex.config.WIDTH - 2,
			tRex.config.HEIGHT - 2);

		const obstacleBox = new CollisionBox(
			obstacle.xPos + 1,
			obstacle.yPos + 1,
			obstacle.typeConfig.width * obstacle.size - 2,
			obstacle.typeConfig.height - 2);

		// Debug outer box
		if (opt_canvasCtx) {
			drawCollisionBoxes(opt_canvasCtx, tRexBox, obstacleBox);
		}

		// Simple outer bounds check.
		if (boxCompare(tRexBox, obstacleBox)) {
			const collisionBoxes = obstacle.collisionBoxes;
			const tRexCollisionBoxes = tRex.ducking ?
				Trex.collisionBoxes.DUCKING : Trex.collisionBoxes.RUNNING;

			// Detailed axis aligned box check.
			for (let t = 0; t < tRexCollisionBoxes.length; t++) {
				for (let i = 0; i < collisionBoxes.length; i++) {
					// Adjust the box to actual positions.
					const adjTrexBox =
						createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox);
					const adjObstacleBox =
						createAdjustedCollisionBox(collisionBoxes[i], obstacleBox);
					const crashed = boxCompare(adjTrexBox, adjObstacleBox);

					// Draw boxes for debug.
					if (opt_canvasCtx) {
						drawCollisionBoxes(opt_canvasCtx, adjTrexBox, adjObstacleBox);
					}

					if (crashed) {
						return [adjTrexBox, adjObstacleBox];
					}
				}
			}
		}
	}


	/**
	 * Adjust the collision box.
	 * @param {!CollisionBox} box The original box.
	 * @param {!CollisionBox} adjustment Adjustment box.
	 * @return {CollisionBox} The adjusted collision box object.
	 */
	function createAdjustedCollisionBox(box, adjustment) {
		return new CollisionBox(
			box.x + adjustment.x,
			box.y + adjustment.y,
			box.width,
			box.height);
	}


	/**
	 * Draw the collision boxes for debug.
	 */
	function drawCollisionBoxes(canvasCtx, tRexBox, obstacleBox) {
		canvasCtx.save();
		canvasCtx.strokeStyle = '#f00';
		canvasCtx.strokeRect(tRexBox.x, tRexBox.y, tRexBox.width, tRexBox.height);

		canvasCtx.strokeStyle = '#0f0';
		canvasCtx.strokeRect(obstacleBox.x, obstacleBox.y,
			obstacleBox.width, obstacleBox.height);
		canvasCtx.restore();
	}


	/**
	 * Compare two collision boxes for a collision.
	 * @param {CollisionBox} tRexBox
	 * @param {CollisionBox} obstacleBox
	 * @return {boolean} Whether the boxes intersected.
	 */
	function boxCompare(tRexBox, obstacleBox) {
		let crashed = false;
		const tRexBoxX = tRexBox.x;
		const tRexBoxY = tRexBox.y;

		const obstacleBoxX = obstacleBox.x;
		const obstacleBoxY = obstacleBox.y;

		// Axis-Aligned Bounding Box method.
		if (tRexBox.x < obstacleBoxX + obstacleBox.width &&
			tRexBox.x + tRexBox.width > obstacleBoxX &&
			tRexBox.y < obstacleBox.y + obstacleBox.height &&
			tRexBox.height + tRexBox.y > obstacleBox.y) {
			crashed = true;
		}

		return crashed;
	}


	//******************************************************************************

	/**
	 * Collision box object.
	 * @param {number} x X position.
	 * @param {number} y Y Position.
	 * @param {number} w Width.
	 * @param {number} h Height.
	 * @constructor
	 */
	function CollisionBox(x, y, w, h) {
		this.x = x;
		this.y = y;
		this.width = w;
		this.height = h;
	}


	//******************************************************************************

	/**
	 * Obstacle.
	 * @param {CanvasRenderingContext2D} canvasCtx
	 * @param {ObstacleType} type
	 * @param {Object} spriteImgPos Obstacle position in sprite.
	 * @param {Object} dimensions
	 * @param {number} gapCoefficient Mutipler in determining the gap.
	 * @param {number} speed
	 * @param {number=} opt_xOffset
	 * @constructor
	 */
	function Obstacle(canvasCtx, type, spriteImgPos, dimensions,
	                  gapCoefficient, speed, opt_xOffset) {

		this.canvasCtx = canvasCtx;
		this.spritePos = spriteImgPos;
		this.typeConfig = type;
		this.gapCoefficient = gapCoefficient;
		this.size = getRandomNum(1, Obstacle.MAX_OBSTACLE_LENGTH);
		this.dimensions = dimensions;
		this.remove = false;
		this.xPos = dimensions.WIDTH + (opt_xOffset || 0);
		this.yPos = 0;
		this.width = 0;
		this.collisionBoxes = [];
		this.gap = 0;
		this.speedOffset = 0;

		// For animated obstacles.
		this.currentFrame = 0;
		this.timer = 0;

		this.init(speed);
	}

	/**
	 * Coefficient for calculating the maximum gap.
	 * @const
	 */
	Obstacle.MAX_GAP_COEFFICIENT = 1.5;

	/**
	 * Maximum obstacle grouping count.
	 * @const
	 */
	Obstacle.MAX_OBSTACLE_LENGTH = 3;


	Obstacle.prototype = {
		/**
		 * Initialise the DOM for the obstacle.
		 * @param {number} speed
		 */
		init(speed) {
			this.cloneCollisionBoxes();

			// Only allow sizing if we're at the right speed.
			if (this.size > 1 && this.typeConfig.multipleSpeed > speed) {
				this.size = 1;
			}

			this.width = this.typeConfig.width * this.size;

			// Check if obstacle can be positioned at various heights.
			if (Array.isArray(this.typeConfig.yPos)) {
				const yPosConfig =
					IS_MOBILE ? this.typeConfig.yPosMobile : this.typeConfig.yPos;
				this.yPos = yPosConfig[getRandomNum(0, yPosConfig.length - 1)];
			} else {
				this.yPos = this.typeConfig.yPos;
			}

			this.draw();

			// Make collision box adjustments,
			// Central box is adjusted to the size as one box.
			//      ____        ______        ________
			//    _|   |-|    _|     |-|    _|       |-|
			//   | |<->| |   | |<--->| |   | |<----->| |
			//   | | 1 | |   | |  2  | |   | |   3   | |
			//   |_|___|_|   |_|_____|_|   |_|_______|_|
			//
			if (this.size > 1) {
				this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width -
					this.collisionBoxes[2].width;
				this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;
			}

			// For obstacles that go at a different speed from the horizon.
			if (this.typeConfig.speedOffset) {
				this.speedOffset = Math.random() > 0.5 ? this.typeConfig.speedOffset :
					-this.typeConfig.speedOffset;
			}

			this.gap = this.getGap(this.gapCoefficient, speed);
		},

		/**
		 * Draw and crop based on size.
		 */
		draw() {
			let sourceWidth = this.typeConfig.width;
			let sourceHeight = this.typeConfig.height;

			if (IS_HIDPI) {
				sourceWidth = sourceWidth * 2;
				sourceHeight = sourceHeight * 2;
			}

			// X position in sprite.
			let sourceX =
				(sourceWidth * this.size) * (0.5 * (this.size - 1)) + this.spritePos.x;

			// Animation frames.
			if (this.currentFrame > 0) {
				sourceX += sourceWidth * this.currentFrame;
			}

			this.canvasCtx.drawImage(
				Runner.imageSprite, sourceX, this.spritePos.y, sourceWidth * this.size,
				sourceHeight, this.xPos, this.yPos, this.typeConfig.width * this.size,
				this.typeConfig.height);
		},

		/**
		 * Obstacle frame update.
		 * @param {number} deltaTime
		 * @param {number} speed
		 */
		update(deltaTime, speed) {
			if (!this.remove) {
				if (this.typeConfig.speedOffset) {
					speed += this.speedOffset;
				}
				this.xPos -= Math.floor((speed * FPS / 1000) * deltaTime);

				// Update frame
				if (this.typeConfig.numFrames) {
					this.timer += deltaTime;
					if (this.timer >= this.typeConfig.frameRate) {
						this.currentFrame =
							this.currentFrame === this.typeConfig.numFrames - 1 ?
								0 :
								this.currentFrame + 1;
						this.timer = 0;
					}
				}
				this.draw();

				if (!this.isVisible()) {
					this.remove = true;
				}
			}
		},

		/**
		 * Calculate a random gap size.
		 * - Minimum gap gets wider as speed increses
		 * @param {number} gapCoefficient
		 * @param {number} speed
		 * @return {number} The gap size.
		 */
		getGap(gapCoefficient, speed) {
			const minGap = Math.round(
				this.width * speed + this.typeConfig.minGap * gapCoefficient);
			const maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT);
			return getRandomNum(minGap, maxGap);
		},

		/**
		 * Check if obstacle is visible.
		 * @return {boolean} Whether the obstacle is in the game area.
		 */
		isVisible() {
			return this.xPos + this.width > 0;
		},

		/**
		 * Make a copy of the collision boxes, since these will change based on
		 * obstacle type and size.
		 */
		cloneCollisionBoxes() {
			const collisionBoxes = this.typeConfig.collisionBoxes;

			for (let i = collisionBoxes.length - 1; i >= 0; i--) {
				this.collisionBoxes[i] = new CollisionBox(
					collisionBoxes[i].x, collisionBoxes[i].y, collisionBoxes[i].width,
					collisionBoxes[i].height);
			}
		},
	};

	/**
	 * Obstacle definitions.
	 * minGap: minimum pixel space betweeen obstacles.
	 * multipleSpeed: Speed at which multiples are allowed.
	 * speedOffset: speed faster / slower than the horizon.
	 * minSpeed: Minimum speed which the obstacle can make an appearance.
	 *
	 * @typedef {{
	 *   type: string,
	 *   width: number,
	 *   height: number,
	 *   yPos: number,
	 *   multipleSpeed: number,
	 *   minGap: number,
	 *   minSpeed: number,
	 *   collisionBoxes: Array<CollisionBox>,
	 * }}
	 */
	let ObstacleType;

	/** @type {Array<ObstacleType>} */
	Obstacle.types = [
		{
			type: 'CACTUS_SMALL',
			width: 17,
			height: 35,
			yPos: 105,
			multipleSpeed: 4,
			minGap: 120,
			minSpeed: 0,
			collisionBoxes: [
				new CollisionBox(0, 7, 5, 27),
				new CollisionBox(4, 0, 6, 34),
				new CollisionBox(10, 4, 7, 14),
			],
		},
		{
			type: 'CACTUS_LARGE',
			width: 25,
			height: 50,
			yPos: 90,
			multipleSpeed: 7,
			minGap: 120,
			minSpeed: 0,
			collisionBoxes: [
				new CollisionBox(0, 12, 7, 38),
				new CollisionBox(8, 0, 7, 49),
				new CollisionBox(13, 10, 10, 38),
			],
		},
		{
			type: 'PTERODACTYL',
			width: 46,
			height: 40,
			yPos: [100, 75, 50], // Variable height.
			yPosMobile: [100, 50], // Variable height mobile.
			multipleSpeed: 999,
			minSpeed: 8.5,
			minGap: 150,
			collisionBoxes: [
				new CollisionBox(15, 15, 16, 5),
				new CollisionBox(18, 21, 24, 6),
				new CollisionBox(2, 14, 4, 3),
				new CollisionBox(6, 10, 4, 7),
				new CollisionBox(10, 8, 6, 9),
			],
			numFrames: 2,
			frameRate: 1000 / 6,
			speedOffset: .8,
		},
	];


	//******************************************************************************
	/**
	 * T-rex game character.
	 * @param {HTMLCanvasElement} canvas
	 * @param {Object} spritePos Positioning within image sprite.
	 * @constructor
	 */
	function Trex(canvas, spritePos) {
		this.canvas = canvas;
		this.canvasCtx =
			/** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
		this.spritePos = spritePos;
		this.xPos = 0;
		this.yPos = 0;
		this.xInitialPos = 0;
		// Position when on the ground.
		this.groundYPos = 0;
		this.currentFrame = 0;
		this.currentAnimFrames = [];
		this.blinkDelay = 0;
		this.blinkCount = 0;
		this.animStartTime = 0;
		this.timer = 0;
		this.msPerFrame = 1000 / FPS;
		this.config = Trex.config;
		// Current status.
		this.status = Trex.status.WAITING;
		this.jumping = false;
		this.ducking = false;
		this.jumpVelocity = 0;
		this.reachedMinHeight = false;
		this.speedDrop = false;
		this.jumpCount = 0;
		this.jumpspotX = 0;

		this.init();
	}


	/**
	 * T-rex player config.
	 */
	Trex.config = {
		DROP_VELOCITY: -5,
		GRAVITY: 0.6,
		HEIGHT: 47,
		HEIGHT_DUCK: 25,
		INIITAL_JUMP_VELOCITY: -10,
		INTRO_DURATION: 1500,
		MAX_JUMP_HEIGHT: 30,
		MIN_JUMP_HEIGHT: 30,
		SPEED_DROP_COEFFICIENT: 3,
		SPRITE_WIDTH: 262,
		START_X_POS: 50,
		WIDTH: 44,
		WIDTH_DUCK: 59,
	};


	/**
	 * Used in collision detection.
	 * @enum {Array<CollisionBox>}
	 */
	Trex.collisionBoxes = {
		DUCKING: [
			new CollisionBox(1, 18, 55, 25),
		],
		RUNNING: [
			new CollisionBox(22, 0, 17, 16),
			new CollisionBox(1, 18, 30, 9),
			new CollisionBox(10, 35, 14, 8),
			new CollisionBox(1, 24, 29, 5),
			new CollisionBox(5, 30, 21, 4),
			new CollisionBox(9, 34, 15, 4),
		],
	};


	/**
	 * Animation states.
	 * @enum {string}
	 */
	Trex.status = {
		CRASHED: 'CRASHED',
		DUCKING: 'DUCKING',
		JUMPING: 'JUMPING',
		RUNNING: 'RUNNING',
		WAITING: 'WAITING',
	};

	/**
	 * Blinking coefficient.
	 * @const
	 */
	Trex.BLINK_TIMING = 7000;


	/**
	 * Animation config for different states.
	 * @enum {Object}
	 */
	Trex.animFrames = {
		WAITING: {
			frames: [44, 0],
			msPerFrame: 1000 / 3,
		},
		RUNNING: {
			frames: [88, 132],
			msPerFrame: 1000 / 12,
		},
		CRASHED: {
			frames: [220],
			msPerFrame: 1000 / 60,
		},
		JUMPING: {
			frames: [0],
			msPerFrame: 1000 / 60,
		},
		DUCKING: {
			frames: [264, 323],
			msPerFrame: 1000 / 8,
		},
	};


	Trex.prototype = {
		/**
		 * T-rex player initaliser.
		 * Sets the t-rex to blink at random intervals.
		 */
		init() {
			this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -
				Runner.config.BOTTOM_PAD;
			this.yPos = this.groundYPos;
			this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT;

			this.draw(0, 0);
			this.update(0, Trex.status.WAITING);
		},

		/**
		 * Setter for the jump velocity.
		 * The approriate drop velocity is also set.
		 * @param {number} setting
		 */
		setJumpVelocity(setting) {
			this.config.INIITAL_JUMP_VELOCITY = -setting;
			this.config.DROP_VELOCITY = -setting / 2;
		},

		/**
		 * Set the animation status.
		 * @param {!number} deltaTime
		 * @param {Trex.status=} opt_status Optional status to switch to.
		 */
		update(deltaTime, opt_status) {
			this.timer += deltaTime;

			// Update the status.
			if (opt_status) {
				this.status = opt_status;
				this.currentFrame = 0;
				this.msPerFrame = Trex.animFrames[opt_status].msPerFrame;
				this.currentAnimFrames = Trex.animFrames[opt_status].frames;

				if (opt_status === Trex.status.WAITING) {
					this.animStartTime = getTimeStamp();
					this.setBlinkDelay();
				}
			}

			// Game intro animation, T-rex moves in from the left.
			if (this.playingIntro && this.xPos < this.config.START_X_POS) {
				this.xPos += Math.round((this.config.START_X_POS /
					this.config.INTRO_DURATION) * deltaTime);
				this.xInitialPos = this.xPos;
			}

			if (this.status === Trex.status.WAITING) {
				this.blink(getTimeStamp());
			} else {
				this.draw(this.currentAnimFrames[this.currentFrame], 0);
			}

			// Update the frame position.
			if (this.timer >= this.msPerFrame) {
				this.currentFrame = this.currentFrame ==
				this.currentAnimFrames.length - 1 ? 0 : this.currentFrame + 1;
				this.timer = 0;
			}

			// Speed drop becomes duck if the down key is still being pressed.
			if (this.speedDrop && this.yPos === this.groundYPos) {
				this.speedDrop = false;
				this.setDuck(true);
			}
		},

		/**
		 * Draw the t-rex to a particular position.
		 * @param {number} x
		 * @param {number} y
		 */
		draw(x, y) {
			let sourceX = x;
			let sourceY = y;
			let sourceWidth = this.ducking && this.status !== Trex.status.CRASHED ?
				this.config.WIDTH_DUCK :
				this.config.WIDTH;
			let sourceHeight = this.config.HEIGHT;
			const outputHeight = sourceHeight;

			if (IS_HIDPI) {
				sourceX *= 2;
				sourceY *= 2;
				sourceWidth *= 2;
				sourceHeight *= 2;
			}

			// Adjustments for sprite sheet position.
			sourceX += this.spritePos.x;
			sourceY += this.spritePos.y;

			// Ducking.
			if (this.ducking && this.status !== Trex.status.CRASHED) {
				this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
					sourceWidth, sourceHeight,
					this.xPos, this.yPos,
					this.config.WIDTH_DUCK, outputHeight);
			} else {
				// Crashed whilst ducking. Trex is standing up so needs adjustment.
				if (this.ducking && this.status === Trex.status.CRASHED) {
					this.xPos++;
				}
				// Standing / running
				this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
					sourceWidth, sourceHeight,
					this.xPos, this.yPos,
					this.config.WIDTH, outputHeight);
			}
			this.canvasCtx.globalAlpha = 1;
		},

		/**
		 * Sets a random time for the blink to happen.
		 */
		setBlinkDelay() {
			this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING);
		},

		/**
		 * Make t-rex blink at random intervals.
		 * @param {number} time Current time in milliseconds.
		 */
		blink(time) {
			const deltaTime = time - this.animStartTime;

			if (deltaTime >= this.blinkDelay) {
				this.draw(this.currentAnimFrames[this.currentFrame], 0);

				if (this.currentFrame === 1) {
					// Set new random delay to blink.
					this.setBlinkDelay();
					this.animStartTime = time;
					this.blinkCount++;
				}
			}
		},

		/**
		 * Initialise a jump.
		 * @param {number} speed
		 */
		startJump(speed) {
			if (!this.jumping) {
				this.update(0, Trex.status.JUMPING);
				// Tweak the jump velocity based on the speed.
				this.jumpVelocity = this.config.INIITAL_JUMP_VELOCITY - (speed / 10);
				this.jumping = true;
				this.reachedMinHeight = false;
				this.speedDrop = false;
			}
		},

		/**
		 * Jump is complete, falling down.
		 */
		endJump() {
			if (this.reachedMinHeight &&
				this.jumpVelocity < this.config.DROP_VELOCITY) {
				this.jumpVelocity = this.config.DROP_VELOCITY;
			}
		},

		/**
		 * Update frame for a jump.
		 * @param {number} deltaTime
		 */
		updateJump(deltaTime) {
			const msPerFrame = Trex.animFrames[this.status].msPerFrame;
			const framesElapsed = deltaTime / msPerFrame;

			// Speed drop makes Trex fall faster.
			if (this.speedDrop) {
				this.yPos += Math.round(this.jumpVelocity *
					this.config.SPEED_DROP_COEFFICIENT * framesElapsed);
			} else {
				this.yPos += Math.round(this.jumpVelocity * framesElapsed);
			}

			this.jumpVelocity += this.config.GRAVITY * framesElapsed;

			// Minimum height has been reached.
			if (this.yPos < this.minJumpHeight || this.speedDrop) {
				this.reachedMinHeight = true;
			}

			// Reached max height
			if (this.yPos < this.config.MAX_JUMP_HEIGHT || this.speedDrop) {
				this.endJump();
			}

			// Back down at ground level. Jump completed.
			if (this.yPos > this.groundYPos) {
				this.reset();
				this.jumpCount++;
			}
		},

		/**
		 * Set the speed drop. Immediately cancels the current jump.
		 */
		setSpeedDrop() {
			this.speedDrop = true;
			this.jumpVelocity = 1;
		},

		/**
		 * @param {boolean} isDucking
		 */
		setDuck(isDucking) {
			if (isDucking && this.status !== Trex.status.DUCKING) {
				this.update(0, Trex.status.DUCKING);
				this.ducking = true;
			} else if (this.status === Trex.status.DUCKING) {
				this.update(0, Trex.status.RUNNING);
				this.ducking = false;
			}
		},

		/**
		 * Reset the t-rex to running at start of game.
		 */
		reset() {
			this.xPos = this.xInitialPos;
			this.yPos = this.groundYPos;
			this.jumpVelocity = 0;
			this.jumping = false;
			this.ducking = false;
			this.update(0, Trex.status.RUNNING);
			this.midair = false;
			this.speedDrop = false;
			this.jumpCount = 0;
		},
	};


	//******************************************************************************

	/**
	 * Handles displaying the distance meter.
	 * @param {!HTMLCanvasElement} canvas
	 * @param {Object} spritePos Image position in sprite.
	 * @param {number} canvasWidth
	 * @constructor
	 */
	function DistanceMeter(canvas, spritePos, canvasWidth) {
		this.canvas = canvas;
		this.canvasCtx =
			/** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
		this.image = Runner.imageSprite;
		this.spritePos = spritePos;
		this.x = 0;
		this.y = 5;

		this.currentDistance = 0;
		this.maxScore = 0;
		this.highScore = '0';
		this.container = null;

		this.digits = [];
		this.achievement = false;
		this.defaultString = '';
		this.flashTimer = 0;
		this.flashIterations = 0;
		this.invertTrigger = false;
		this.flashingRafId = null;
		this.highScoreBounds = {};
		this.highScoreFlashing = false;

		this.config = DistanceMeter.config;
		this.maxScoreUnits = this.config.MAX_DISTANCE_UNITS;
		this.init(canvasWidth);
	}


	/**
	 * @enum {number}
	 */
	DistanceMeter.dimensions = {
		WIDTH: 10,
		HEIGHT: 13,
		DEST_WIDTH: 11,
	};


	/**
	 * Y positioning of the digits in the sprite sheet.
	 * X position is always 0.
	 * @type {Array<number>}
	 */
	DistanceMeter.yPos = [0, 13, 27, 40, 53, 67, 80, 93, 107, 120];


	/**
	 * Distance meter config.
	 * @enum {number}
	 */
	DistanceMeter.config = {
		// Number of digits.
		MAX_DISTANCE_UNITS: 5,

		// Distance that causes achievement animation.
		ACHIEVEMENT_DISTANCE: 100,

		// Used for conversion from pixel distance to a scaled unit.
		COEFFICIENT: 0.025,

		// Flash duration in milliseconds.
		FLASH_DURATION: 1000 / 4,

		// Flash iterations for achievement animation.
		FLASH_ITERATIONS: 3,

		// Padding around the high score hit area.
		HIGH_SCORE_HIT_AREA_PADDING: 4,
	};


	DistanceMeter.prototype = {
		/**
		 * Initialise the distance meter to '00000'.
		 * @param {number} width Canvas width in px.
		 */
		init(width) {
			let maxDistanceStr = '';

			this.calcXPos(width);
			this.maxScore = this.maxScoreUnits;
			for (let i = 0; i < this.maxScoreUnits; i++) {
				this.draw(i, 0);
				this.defaultString += '0';
				maxDistanceStr += '9';
			}

			this.maxScore = parseInt(maxDistanceStr, 10);
		},

		/**
		 * Calculate the xPos in the canvas.
		 * @param {number} canvasWidth
		 */
		calcXPos(canvasWidth) {
			this.x = canvasWidth - (DistanceMeter.dimensions.DEST_WIDTH *
				(this.maxScoreUnits + 1));
		},

		/**
		 * Draw a digit to canvas.
		 * @param {number} digitPos Position of the digit.
		 * @param {number} value Digit value 0-9.
		 * @param {boolean=} opt_highScore Whether drawing the high score.
		 */
		draw(digitPos, value, opt_highScore) {
			let sourceWidth = DistanceMeter.dimensions.WIDTH;
			let sourceHeight = DistanceMeter.dimensions.HEIGHT;
			let sourceX = DistanceMeter.dimensions.WIDTH * value;
			let sourceY = 0;

			const targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH;
			const targetY = this.y;
			const targetWidth = DistanceMeter.dimensions.WIDTH;
			const targetHeight = DistanceMeter.dimensions.HEIGHT;

			// For high DPI we 2x source values.
			if (IS_HIDPI) {
				sourceWidth *= 2;
				sourceHeight *= 2;
				sourceX *= 2;
			}

			sourceX += this.spritePos.x;
			sourceY += this.spritePos.y;

			this.canvasCtx.save();

			if (opt_highScore) {
				// Left of the current score.
				const highScoreX = this.x - (this.maxScoreUnits * 2) *
					DistanceMeter.dimensions.WIDTH;
				this.canvasCtx.translate(highScoreX, this.y);
			} else {
				this.canvasCtx.translate(this.x, this.y);
			}

			this.canvasCtx.drawImage(this.image, sourceX, sourceY,
				sourceWidth, sourceHeight,
				targetX, targetY,
				targetWidth, targetHeight,
			);

			this.canvasCtx.restore();
		},

		/**
		 * Covert pixel distance to a 'real' distance.
		 * @param {number} distance Pixel distance ran.
		 * @return {number} The 'real' distance ran.
		 */
		getActualDistance(distance) {
			return distance ? Math.round(distance * this.config.COEFFICIENT) : 0;
		},

		/**
		 * Update the distance meter.
		 * @param {number} distance
		 * @param {number} deltaTime
		 * @return {boolean} Whether the acheivement sound fx should be played.
		 */
		update(deltaTime, distance) {
			let paint = true;
			let playSound = false;

			if (!this.achievement) {
				distance = this.getActualDistance(distance);
				// Score has gone beyond the initial digit count.
				if (distance > this.maxScore && this.maxScoreUnits ==
					this.config.MAX_DISTANCE_UNITS) {
					this.maxScoreUnits++;
					this.maxScore = parseInt(this.maxScore + '9', 10);
				} else {
					this.distance = 0;
				}

				if (distance > 0) {
					// Achievement unlocked.
					if (distance % this.config.ACHIEVEMENT_DISTANCE === 0) {
						// Flash score and play sound.
						this.achievement = true;
						this.flashTimer = 0;
						playSound = true;
					}

					// Create a string representation of the distance with leading 0.
					const distanceStr = (this.defaultString +
						distance).substr(-this.maxScoreUnits);
					this.digits = distanceStr.split('');
				} else {
					this.digits = this.defaultString.split('');
				}
			} else {
				// Control flashing of the score on reaching acheivement.
				if (this.flashIterations <= this.config.FLASH_ITERATIONS) {
					this.flashTimer += deltaTime;

					if (this.flashTimer < this.config.FLASH_DURATION) {
						paint = false;
					} else if (this.flashTimer >
						this.config.FLASH_DURATION * 2) {
						this.flashTimer = 0;
						this.flashIterations++;
					}
				} else {
					this.achievement = false;
					this.flashIterations = 0;
					this.flashTimer = 0;
				}
			}

			// Draw the digits if not flashing.
			if (paint) {
				for (let i = this.digits.length - 1; i >= 0; i--) {
					this.draw(i, parseInt(this.digits[i], 10));
				}
			}

			this.drawHighScore();
			return playSound;
		},

		/**
		 * Draw the high score.
		 */
		drawHighScore() {
			this.canvasCtx.save();
			this.canvasCtx.globalAlpha = .8;
			for (let i = this.highScore.length - 1; i >= 0; i--) {
				this.draw(i, parseInt(this.highScore[i], 10), true);
			}
			this.canvasCtx.restore();
		},

		/**
		 * Set the highscore as a array string.
		 * Position of char in the sprite: H - 10, I - 11.
		 * @param {number} distance Distance ran in pixels.
		 */
		setHighScore(distance) {
			distance = this.getActualDistance(distance);
			const highScoreStr = (this.defaultString +
				distance).substr(-this.maxScoreUnits);

			this.highScore = ['10', '11', ''].concat(highScoreStr.split(''));
		},


		/**
		 * Whether a clicked is in the high score area.
		 * @param {Event} e Event object.
		 * @return {boolean} Whether the click was in the high score bounds.
		 */
		hasClickedOnHighScore(e) {
			let x = 0;
			let y = 0;

			if (e.touches) {
				// Bounds for touch differ from pointer.
				const canvasBounds = this.canvas.getBoundingClientRect();
				x = e.touches[0].clientX - canvasBounds.left;
				y = e.touches[0].clientY - canvasBounds.top;
			} else {
				x = e.offsetX;
				y = e.offsetY;
			}

			this.highScoreBounds = this.getHighScoreBounds();
			return x >= this.highScoreBounds.x && x <=
				this.highScoreBounds.x + this.highScoreBounds.width &&
				y >= this.highScoreBounds.y && y <=
				this.highScoreBounds.y + this.highScoreBounds.height;
		},

		/**
		 * Get the bounding box for the high score.
		 * @return {Object} Object with x, y, width and height properties.
		 */
		getHighScoreBounds() {
			return {
				x: (this.x - (this.maxScoreUnits * 2) *
					DistanceMeter.dimensions.WIDTH) -
					DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING,
				y: this.y,
				width: DistanceMeter.dimensions.WIDTH * (this.highScore.length + 1) +
					DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING,
				height: DistanceMeter.dimensions.HEIGHT +
					(DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING * 2),
			};
		},

		/**
		 * Animate flashing the high score to indicate ready for resetting.
		 * The flashing stops following this.config.FLASH_ITERATIONS x 2 flashes.
		 */
		flashHighScore() {
			const now = getTimeStamp();
			const deltaTime = now - (this.frameTimeStamp || now);
			let paint = true;
			this.frameTimeStamp = now;

			// Reached the max number of flashes.
			if (this.flashIterations > this.config.FLASH_ITERATIONS * 2) {
				this.cancelHighScoreFlashing();
				return;
			}

			this.flashTimer += deltaTime;

			if (this.flashTimer < this.config.FLASH_DURATION) {
				paint = false;
			} else if (this.flashTimer > this.config.FLASH_DURATION * 2) {
				this.flashTimer = 0;
				this.flashIterations++;
			}

			if (paint) {
				this.drawHighScore();
			} else {
				this.clearHighScoreBounds();
			}
			// Frame update.
			this.flashingRafId =
				requestAnimationFrame(this.flashHighScore.bind(this));
		},

		/**
		 * Draw empty rectangle over high score.
		 */
		clearHighScoreBounds() {
			this.canvasCtx.save();
			this.canvasCtx.fillStyle = '#fff';
			this.canvasCtx.rect(this.highScoreBounds.x, this.highScoreBounds.y,
				this.highScoreBounds.width, this.highScoreBounds.height);
			this.canvasCtx.fill();
			this.canvasCtx.restore();
		},

		/**
		 * Starts the flashing of the high score.
		 */
		startHighScoreFlashing() {
			this.highScoreFlashing = true;
			this.flashHighScore();
		},

		/**
		 * Whether high score is flashing.
		 * @return {boolean}
		 */
		isHighScoreFlashing() {
			return this.highScoreFlashing;
		},

		/**
		 * Stop flashing the high score.
		 */
		cancelHighScoreFlashing() {
			if (this.flashingRafId) {
				cancelAnimationFrame(this.flashingRafId);
			}
			this.flashIterations = 0;
			this.flashTimer = 0;
			this.highScoreFlashing = false;
			this.clearHighScoreBounds();
			this.drawHighScore();
		},

		/**
		 * Clear the high score.
		 */
		resetHighScore() {
			this.setHighScore(0);
			this.cancelHighScoreFlashing();
		},

		/**
		 * Reset the distance meter back to '00000'.
		 */
		reset() {
			this.update(0, 0);
			this.achievement = false;
		},
	};


	//******************************************************************************

	/**
	 * Cloud background item.
	 * Similar to an obstacle object but without collision boxes.
	 * @param {HTMLCanvasElement} canvas Canvas element.
	 * @param {Object} spritePos Position of image in sprite.
	 * @param {number} containerWidth
	 * @constructor
	 */
	function Cloud(canvas, spritePos, containerWidth) {
		this.canvas = canvas;
		this.canvasCtx =
			/** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
		this.spritePos = spritePos;
		this.containerWidth = containerWidth;
		this.xPos = containerWidth;
		this.yPos = 0;
		this.remove = false;
		this.cloudGap = getRandomNum(Cloud.config.MIN_CLOUD_GAP,
			Cloud.config.MAX_CLOUD_GAP);

		this.init();
	}


	/**
	 * Cloud object config.
	 * @enum {number}
	 */
	Cloud.config = {
		HEIGHT: 14,
		MAX_CLOUD_GAP: 400,
		MAX_SKY_LEVEL: 30,
		MIN_CLOUD_GAP: 100,
		MIN_SKY_LEVEL: 71,
		WIDTH: 46,
	};


	Cloud.prototype = {
		/**
		 * Initialise the cloud. Sets the Cloud height.
		 */
		init() {
			this.yPos = getRandomNum(Cloud.config.MAX_SKY_LEVEL,
				Cloud.config.MIN_SKY_LEVEL);
			this.draw();
		},

		/**
		 * Draw the cloud.
		 */
		draw() {
			this.canvasCtx.save();
			let sourceWidth = Cloud.config.WIDTH;
			let sourceHeight = Cloud.config.HEIGHT;
			const outputWidth = sourceWidth;
			const outputHeight = sourceHeight;
			if (IS_HIDPI) {
				sourceWidth = sourceWidth * 2;
				sourceHeight = sourceHeight * 2;
			}

			this.canvasCtx.drawImage(Runner.imageSprite, this.spritePos.x,
				this.spritePos.y,
				sourceWidth, sourceHeight,
				this.xPos, this.yPos,
				outputWidth, outputHeight);

			this.canvasCtx.restore();
		},

		/**
		 * Update the cloud position.
		 * @param {number} speed
		 */
		update(speed) {
			if (!this.remove) {
				this.xPos -= Math.ceil(speed);
				this.draw();

				// Mark as removeable if no longer in the canvas.
				if (!this.isVisible()) {
					this.remove = true;
				}
			}
		},

		/**
		 * Check if the cloud is visible on the stage.
		 * @return {boolean}
		 */
		isVisible() {
			return this.xPos + Cloud.config.WIDTH > 0;
		},
	};


	//******************************************************************************

	/**
	 * Nightmode shows a moon and stars on the horizon.
	 * @param {HTMLCanvasElement} canvas
	 * @param {number} spritePos
	 * @param {number} containerWidth
	 * @constructor
	 */
	function NightMode(canvas, spritePos, containerWidth) {
		this.spritePos = spritePos;
		this.canvas = canvas;
		this.canvasCtx =
			/** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
		this.xPos = containerWidth - 50;
		this.yPos = 30;
		this.currentPhase = 0;
		this.opacity = 0;
		this.containerWidth = containerWidth;
		this.stars = [];
		this.drawStars = false;
		this.placeStars();
	}

	/**
	 * @enum {number}
	 */
	NightMode.config = {
		FADE_SPEED: 0.035,
		HEIGHT: 40,
		MOON_SPEED: 0.25,
		NUM_STARS: 2,
		STAR_SIZE: 9,
		STAR_SPEED: 0.3,
		STAR_MAX_Y: 70,
		WIDTH: 20,
	};

	NightMode.phases = [140, 120, 100, 60, 40, 20, 0];

	NightMode.prototype = {
		/**
		 * Update moving moon, changing phases.
		 * @param {boolean} activated Whether night mode is activated.
		 */
		update(activated) {
			// Moon phase.
			if (activated && this.opacity === 0) {
				this.currentPhase++;

				if (this.currentPhase >= NightMode.phases.length) {
					this.currentPhase = 0;
				}
			}

			// Fade in / out.
			if (activated && (this.opacity < 1 || this.opacity === 0)) {
				this.opacity += NightMode.config.FADE_SPEED;
			} else if (this.opacity > 0) {
				this.opacity -= NightMode.config.FADE_SPEED;
			}

			// Set moon positioning.
			if (this.opacity > 0) {
				this.xPos = this.updateXPos(this.xPos, NightMode.config.MOON_SPEED);

				// Update stars.
				if (this.drawStars) {
					for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
						this.stars[i].x =
							this.updateXPos(this.stars[i].x, NightMode.config.STAR_SPEED);
					}
				}
				this.draw();
			} else {
				this.opacity = 0;
				this.placeStars();
			}
			this.drawStars = true;
		},

		updateXPos(currentPos, speed) {
			if (currentPos < -NightMode.config.WIDTH) {
				currentPos = this.containerWidth;
			} else {
				currentPos -= speed;
			}
			return currentPos;
		},

		draw() {
			let moonSourceWidth = this.currentPhase === 3 ? NightMode.config.WIDTH * 2 :
				NightMode.config.WIDTH;
			let moonSourceHeight = NightMode.config.HEIGHT;
			let moonSourceX = this.spritePos.x + NightMode.phases[this.currentPhase];
			const moonOutputWidth = moonSourceWidth;
			let starSize = NightMode.config.STAR_SIZE;
			let starSourceX = Runner.spriteDefinition.LDPI.STAR.x;

			if (IS_HIDPI) {
				moonSourceWidth *= 2;
				moonSourceHeight *= 2;
				moonSourceX = this.spritePos.x +
					(NightMode.phases[this.currentPhase] * 2);
				starSize *= 2;
				starSourceX = Runner.spriteDefinition.HDPI.STAR.x;
			}

			this.canvasCtx.save();
			this.canvasCtx.globalAlpha = this.opacity;

			// Stars.
			if (this.drawStars) {
				for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
					this.canvasCtx.drawImage(Runner.imageSprite,
						starSourceX, this.stars[i].sourceY, starSize, starSize,
						Math.round(this.stars[i].x), this.stars[i].y,
						NightMode.config.STAR_SIZE, NightMode.config.STAR_SIZE);
				}
			}

			// Moon.
			this.canvasCtx.drawImage(Runner.imageSprite, moonSourceX,
				this.spritePos.y, moonSourceWidth, moonSourceHeight,
				Math.round(this.xPos), this.yPos,
				moonOutputWidth, NightMode.config.HEIGHT);

			this.canvasCtx.globalAlpha = 1;
			this.canvasCtx.restore();
		},

		// Do star placement.
		placeStars() {
			const segmentSize = Math.round(this.containerWidth /
				NightMode.config.NUM_STARS);

			for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
				this.stars[i] = {};
				this.stars[i].x = getRandomNum(segmentSize * i, segmentSize * (i + 1));
				this.stars[i].y = getRandomNum(0, NightMode.config.STAR_MAX_Y);

				if (IS_HIDPI) {
					this.stars[i].sourceY = Runner.spriteDefinition.HDPI.STAR.y +
						NightMode.config.STAR_SIZE * 2 * i;
				} else {
					this.stars[i].sourceY = Runner.spriteDefinition.LDPI.STAR.y +
						NightMode.config.STAR_SIZE * i;
				}
			}
		},

		reset() {
			this.currentPhase = 0;
			this.opacity = 0;
			this.update(false);
		},

	};


	//******************************************************************************

	/**
	 * Horizon Line.
	 * Consists of two connecting lines. Randomly assigns a flat / bumpy horizon.
	 * @param {HTMLCanvasElement} canvas
	 * @param {Object} spritePos Horizon position in sprite.
	 * @constructor
	 */
	function HorizonLine(canvas, spritePos) {
		this.spritePos = spritePos;
		this.canvas = canvas;
		this.canvasCtx =
			/** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
		this.sourceDimensions = {};
		this.dimensions = HorizonLine.dimensions;
		this.sourceXPos = [this.spritePos.x, this.spritePos.x +
		this.dimensions.WIDTH];
		this.xPos = [];
		this.yPos = 0;
		this.bumpThreshold = 0.5;

		this.setSourceDimensions();
		this.draw();
	}


	/**
	 * Horizon line dimensions.
	 * @enum {number}
	 */
	HorizonLine.dimensions = {
		WIDTH: 600,
		HEIGHT: 12,
		YPOS: 127,
	};


	HorizonLine.prototype = {
		/**
		 * Set the source dimensions of the horizon line.
		 */
		setSourceDimensions() {
			for (const dimension in HorizonLine.dimensions) {
				if (IS_HIDPI) {
					if (dimension !== 'YPOS') {
						this.sourceDimensions[dimension] =
							HorizonLine.dimensions[dimension] * 2;
					}
				} else {
					this.sourceDimensions[dimension] =
						HorizonLine.dimensions[dimension];
				}
				this.dimensions[dimension] = HorizonLine.dimensions[dimension];
			}

			this.xPos = [0, HorizonLine.dimensions.WIDTH];
			this.yPos = HorizonLine.dimensions.YPOS;
		},

		/**
		 * Return the crop x position of a type.
		 */
		getRandomType() {
			return Math.random() > this.bumpThreshold ? this.dimensions.WIDTH : 0;
		},

		/**
		 * Draw the horizon line.
		 */
		draw() {
			this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[0],
				this.spritePos.y,
				this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
				this.xPos[0], this.yPos,
				this.dimensions.WIDTH, this.dimensions.HEIGHT);

			this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[1],
				this.spritePos.y,
				this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
				this.xPos[1], this.yPos,
				this.dimensions.WIDTH, this.dimensions.HEIGHT);
		},

		/**
		 * Update the x position of an indivdual piece of the line.
		 * @param {number} pos Line position.
		 * @param {number} increment
		 */
		updateXPos(pos, increment) {
			const line1 = pos;
			const line2 = pos === 0 ? 1 : 0;

			this.xPos[line1] -= increment;
			this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH;

			if (this.xPos[line1] <= -this.dimensions.WIDTH) {
				this.xPos[line1] += this.dimensions.WIDTH * 2;
				this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH;
				this.sourceXPos[line1] = this.getRandomType() + this.spritePos.x;
			}
		},

		/**
		 * Update the horizon line.
		 * @param {number} deltaTime
		 * @param {number} speed
		 */
		update(deltaTime, speed) {
			const increment = Math.floor(speed * (FPS / 1000) * deltaTime);

			if (this.xPos[0] <= 0) {
				this.updateXPos(0, increment);
			} else {
				this.updateXPos(1, increment);
			}
			this.draw();
		},

		/**
		 * Reset horizon to the starting position.
		 */
		reset() {
			this.xPos[0] = 0;
			this.xPos[1] = HorizonLine.dimensions.WIDTH;
		},
	};


	//******************************************************************************

	/**
	 * Horizon background class.
	 * @param {HTMLCanvasElement} canvas
	 * @param {Object} spritePos Sprite positioning.
	 * @param {Object} dimensions Canvas dimensions.
	 * @param {number} gapCoefficient
	 * @constructor
	 */
	function Horizon(canvas, spritePos, dimensions, gapCoefficient) {
		this.canvas = canvas;
		this.canvasCtx =
			/** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
		this.config = Horizon.config;
		this.dimensions = dimensions;
		this.gapCoefficient = gapCoefficient;
		this.obstacles = [];
		this.obstacleHistory = [];
		this.horizonOffsets = [0, 0];
		this.cloudFrequency = this.config.CLOUD_FREQUENCY;
		this.spritePos = spritePos;
		this.nightMode = null;

		// Cloud
		this.clouds = [];
		this.cloudSpeed = this.config.BG_CLOUD_SPEED;

		// Horizon
		this.horizonLine = null;
		this.init();
	}


	/**
	 * Horizon config.
	 * @enum {number}
	 */
	Horizon.config = {
		BG_CLOUD_SPEED: 0.2,
		BUMPY_THRESHOLD: .3,
		CLOUD_FREQUENCY: .5,
		HORIZON_HEIGHT: 16,
		MAX_CLOUDS: 6,
	};


	Horizon.prototype = {
		/**
		 * Initialise the horizon. Just add the line and a cloud. No obstacles.
		 */
		init() {
			this.addCloud();
			this.horizonLine = new HorizonLine(this.canvas, this.spritePos.HORIZON);
			this.nightMode = new NightMode(this.canvas, this.spritePos.MOON,
				this.dimensions.WIDTH);
		},

		/**
		 * @param {number} deltaTime
		 * @param {number} currentSpeed
		 * @param {boolean} updateObstacles Used as an override to prevent
		 *     the obstacles from being updated / added. This happens in the
		 *     ease in section.
		 * @param {boolean} showNightMode Night mode activated.
		 */
		update(deltaTime, currentSpeed, updateObstacles, showNightMode) {
			this.runningTime += deltaTime;
			this.horizonLine.update(deltaTime, currentSpeed);
			this.nightMode.update(showNightMode);
			this.updateClouds(deltaTime, currentSpeed);

			if (updateObstacles) {
				this.updateObstacles(deltaTime, currentSpeed);
			}
		},

		/**
		 * Update the cloud positions.
		 * @param {number} deltaTime
		 * @param {number} speed
		 */
		updateClouds(deltaTime, speed) {
			const cloudSpeed = this.cloudSpeed / 1000 * deltaTime * speed;
			const numClouds = this.clouds.length;

			if (numClouds) {
				for (let i = numClouds - 1; i >= 0; i--) {
					this.clouds[i].update(cloudSpeed);
				}

				const lastCloud = this.clouds[numClouds - 1];

				// Check for adding a new cloud.
				if (numClouds < this.config.MAX_CLOUDS &&
					(this.dimensions.WIDTH - lastCloud.xPos) > lastCloud.cloudGap &&
					this.cloudFrequency > Math.random()) {
					this.addCloud();
				}

				// Remove expired clouds.
				this.clouds = this.clouds.filter(function(obj) {
					return !obj.remove;
				});
			} else {
				this.addCloud();
			}
		},

		/**
		 * Update the obstacle positions.
		 * @param {number} deltaTime
		 * @param {number} currentSpeed
		 */
		updateObstacles(deltaTime, currentSpeed) {
			// Obstacles, move to Horizon layer.
			const updatedObstacles = this.obstacles.slice(0);

			for (let i = 0; i < this.obstacles.length; i++) {
				const obstacle = this.obstacles[i];
				obstacle.update(deltaTime, currentSpeed);

				// Clean up existing obstacles.
				if (obstacle.remove) {
					updatedObstacles.shift();
				}
			}
			this.obstacles = updatedObstacles;

			if (this.obstacles.length > 0) {
				const lastObstacle = this.obstacles[this.obstacles.length - 1];

				if (lastObstacle && !lastObstacle.followingObstacleCreated &&
					lastObstacle.isVisible() &&
					(lastObstacle.xPos + lastObstacle.width + lastObstacle.gap) <
					this.dimensions.WIDTH) {
					this.addNewObstacle(currentSpeed);
					lastObstacle.followingObstacleCreated = true;
				}
			} else {
				// Create new obstacles.
				this.addNewObstacle(currentSpeed);
			}
		},

		removeFirstObstacle() {
			this.obstacles.shift();
		},

		/**
		 * Add a new obstacle.
		 * @param {number} currentSpeed
		 */
		addNewObstacle(currentSpeed) {
			const obstacleTypeIndex = getRandomNum(0, Obstacle.types.length - 1);
			const obstacleType = Obstacle.types[obstacleTypeIndex];

			// Check for multiples of the same type of obstacle.
			// Also check obstacle is available at current speed.
			if (this.duplicateObstacleCheck(obstacleType.type) ||
				currentSpeed < obstacleType.minSpeed) {
				this.addNewObstacle(currentSpeed);
			} else {
				const obstacleSpritePos = this.spritePos[obstacleType.type];

				this.obstacles.push(new Obstacle(this.canvasCtx, obstacleType,
					obstacleSpritePos, this.dimensions,
					this.gapCoefficient, currentSpeed, obstacleType.width));

				this.obstacleHistory.unshift(obstacleType.type);

				if (this.obstacleHistory.length > 1) {
					this.obstacleHistory.splice(Runner.config.MAX_OBSTACLE_DUPLICATION);
				}
			}
		},

		/**
		 * Returns whether the previous two obstacles are the same as the next one.
		 * Maximum duplication is set in config value MAX_OBSTACLE_DUPLICATION.
		 * @return {boolean}
		 */
		duplicateObstacleCheck(nextObstacleType) {
			let duplicateCount = 0;

			for (let i = 0; i < this.obstacleHistory.length; i++) {
				duplicateCount =
					this.obstacleHistory[i] === nextObstacleType ? duplicateCount + 1 : 0;
			}
			return duplicateCount >= Runner.config.MAX_OBSTACLE_DUPLICATION;
		},

		/**
		 * Reset the horizon layer.
		 * Remove existing obstacles and reposition the horizon line.
		 */
		reset() {
			this.obstacles = [];
			this.horizonLine.reset();
			this.nightMode.reset();
		},

		/**
		 * Update the canvas width and scaling.
		 * @param {number} width Canvas width.
		 * @param {number} height Canvas height.
		 */
		resize(width, height) {
			this.canvas.width = width;
			this.canvas.height = height;
		},

		/**
		 * Add a new cloud to the horizon.
		 */
		addCloud() {
			this.clouds.push(new Cloud(this.canvas, this.spritePos.CLOUD,
				this.dimensions.WIDTH));
		},
	};

	</script>


	<style>/* Copyright 2014 The Chromium Authors. All rights reserved.
   Use of this source code is governed by a BSD-style license that can be
   found in the LICENSE file. */

	a {
		color: #585858;
	}

	body {
		background-color: #f7f7f7;
		color: #585858;
		font-size: 125%;
	}

	body.safe-browsing {
		background-color: rgb(206, 52, 38);
		color: white;
	}

	button {
		background: rgb(76, 142, 250);
		border: 0;
		border-radius: 2px;
		box-sizing: border-box;
		color: #fff;
		cursor: pointer;
		float: right;
		font-size: .875em;
		height: 36px;
		margin: -6px 0 0;
		padding: 8px 24px;
		transition: box-shadow 200ms cubic-bezier(0.4, 0, 0.2, 1);
	}

	[dir='rtl'] button {
		float: left;
	}

	button:active {
		background: rgb(50, 102, 213);
		outline: 0;
	}

	button:hover {
		box-shadow: 0 1px 3px rgba(0, 0, 0, .50);
	}

	.debugging-content {
		line-height: 1em;
		margin-bottom: 0;
		margin-top: 0;
	}

	.debugging-title {
		font-weight: bold;
	}

	#details {
		color: #696969;
		margin: 45px 0 50px;
	}

	#details p:not(:first-of-type) {
		margin-top: 20px;
	}

	#error-code {
		color: black;
		opacity: .35;
		text-transform: uppercase;
	}

	#error-debugging-info {
		font-size: 0.8em;
	}

	h1 {
		-webkit-margin-after: 16px;
		color: #585858;
		font-size: 1.6em;
		font-weight: normal;
		line-height: 1.25em;
	}

	h2 {
		font-size: 1.2em;
		font-weight: normal;
	}

	.hidden {
		display: none;
	}

	.icon {
		background-repeat: no-repeat;
		background-size: 100%;
		height: 72px;
		margin: 0 0 40px;
		width: 72px;
	}

	input[type=checkbox] {
		visibility: hidden;
	}

	.interstitial-wrapper {
		box-sizing: border-box;
		font-size: 1em;
		line-height: 1.6em;
		margin: 50px auto 0;
		max-width: 600px;
		width: 100%;
	}

	#malware-opt-in {
		font-size: .875em;
		margin-top: 39px;
	}

	.nav-wrapper {
		margin-top: 51px;
	}

	.nav-wrapper::after {
		clear: both;
		content: '';
		display: table;
		width: 100%;
	}

	#opt-in-label {
		-webkit-margin-start: 32px;
	}

	.safe-browsing :-webkit-any(
    a, #details, #details-button, h1, h2, p, .small-link) {
		color: white;
	}

	.safe-browsing button {
		background-color: rgb(206, 52, 38);
		border: 1px solid white;
	}

	.safe-browsing button:active {
		background-color: rgb(206, 52, 38);
		border-color: rgba(255, 255, 255, .6);
	}

	.safe-browsing button:hover {
		box-shadow: 0 2px 3px rgba(0, 0, 0, .5);
	}

	.safe-browsing .icon {
		background-image: -webkit-image-set(
				url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAMAAABiM0N1AAABoVBMVEX///+Li4v////////y8vL09PT99fTbRDfXzMzt7e3v7+/s7Ozy8vLw8PDu7u799PPSQTXx8fHZdGv19fX09PTm5ubbV0zXzczgW1Dd3d3c3Nzjb2Th4eHr6+vl5eXp6enZ2dng4OD29vbz8/PYYFXZV0zaYVbjbWP219TRQTTXdGz43Nn++/rib2T////b29vTQjXaYVf66ObngXjjbmTq6ura2trngHf76Ofk19bX19fe3t7o6Oji4uLk5OTeU0f119TYQzbZQzbWQjbXQzbZRDfaRDfn5+fbV0vj4+PVQjXf39/Y2Njgcmney8rqk4zdysn43drcysjcUETa1tbadGvaV0vaWEzZYVbibmXc2NjfzMvi0M7mfHPYYVbhzszd2dnZx8XieXDkc2nWX1Xacmne2trZdGzbcWjj0c/XTUHX1NPVX1Xg3NzYdGvYXFHZ1dXWTUHgzczUX1Xh3d3XdWzWXFHaVkvXxcTVTEHhbmXTXlXi3t7ayMbVXFLgbmXUTEDXYFXSXlTXzMvk4ODUXFHWbGPWzMvk4eHZioP39/f9Ro5BAAAABnRSTlMAAOQk5ye8yu+CAAACRklEQVR4XrXWRZPbUBSEUWdmIpl5mJmZg8zMzMzMzPCr43isNqif76u6lW+nuzgrtUqB/1ptzUSVamrVDiS1A0ntQFI7kNQOJLUDSe1AUjuQ1A4ktQNJ70DSO5D0DiS9A0nvQIKjlOAoJThqyewsXZ1hQOL8YZNkcJrcJiIlBt2No0zKQSbHJVJiznW5BIg4kMocSDIEBxKcwvkoJAE6uMJAguO13xIaWyyRiDPdGGGQJBFnzb4Qh2Qp0VrmdHXFCSRKxFmYDAsQpNkSiTgtLZAAydIgcZqbYwQSJOqs3QsJkCRxp7s7RSBBok5bW5RAgkSd9bujIoS3AA0QZ0NHrx3ktLro5SvidNRnAUkO2nWZOPU7s4BEB9J74qzrzACSHNRwhDid8xlAogPpEHHa23sIxJyB60XpAHEioT9myBnf4XWq8W4aDw1niROKA/I7270u5HbxKI3Hk0+IEzZBzuktXn35XRw7jsOJi34nZoCcN5u9+gq7OJPGqf+czzFAzsdtXp+xi0tpHPtvVzopDl3Z6nUtWNzXjZs436p0DNDQnT0r3QuW7vT+g8L54XKlEzX8RAw9nvrX02D53p89z59f+J0602/NptfJZPKt52AX70Zy5w/EWR0wSp+Gv3z1f3++jQx/545Z+vGTfcd+/eYOJFIEDtkpccxSyNqRpLitI0uWjiyFLR1ZignOqoC1VN0BJEupag4gK8nsALKToiYHkK3Uyx0CiRJ3ANlLWe4AspcyxKGQLHEHkL3UQxwKyRJxCKTtLyVXfw+a8JTgAAAAAElFTkSuQmCC) 1x,
				url(data:image/png;base64,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) 2x);
	}

	.small-link {
		color: #696969;
		font-size: .875em;
	}

	.ssl .icon {
		background-image: -webkit-image-set(
				url(data:image/png;base64,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) 1x,
				url(data:image/png;base64,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) 2x);
	}

	.styled-checkbox {
		float: left;
		height: 16px;
		margin-top: .36em;
		position: relative;
		width: 16px;
	}

	[dir='rtl'] .styled-checkbox {
		float: right;
	}

	.styled-checkbox label {
		background: transparent;
		border: white solid 1px;
		border-radius: 2px;
		height: 14px;
		left: 0;
		position: absolute;
		right: 0;
		top: 0;
		width: 14px;
	}

	.styled-checkbox label::after {
		background: transparent;
		border: 2px solid white;
		border-right-width: 0;
		border-top-width: 0;
		content: '';
		height: 4px;
		left: 2px;
		opacity: 0.3;
		position: absolute;
		top: 3px;
		transform: rotate(-45deg);
		width: 9px;
	}

	.styled-checkbox input[type=checkbox]:checked + label::after {
		opacity: 1;
	}

	@media (max-width: 700px) {
		.interstitial-wrapper {
			padding: 0 10%;
		}
	}

	@media (max-height: 600px) {
		.interstitial-wrapper {
			margin-top: 5px;
		}
	}

	@media (max-width: 400px) {
		button,
		[dir='rtl'] button {
			float: none;
			font-size: 1em;
			width: 100%;
		}

		#details {
			margin: 20px 0 20px 0;
		}

		#details p:not(:first-of-type) {
			margin-top: 10px;
		}

		#details-button {
			display: block;
			padding-top: 14px;
			text-align: center;
			width: 100%;
		}

		.interstitial-wrapper {
			padding: 0 5%;
		}

		#malware-opt-in {
			margin-top: 24px;
		}

		.nav-wrapper {
			margin-top: 30px;
		}

		.small-link {
			font-size: 1em;
		}
	}
	</style>
	<style>
	/* Copyright 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file. */

	h1 {
		margin-top: 0;
		word-wrap: break-word;
	}

	h1 span {
		font-weight: 500;
	}

	h2 {
		color: var(--heading-color);
		font-size: 1.2em;
		font-weight: normal;
		margin: 10px 0;
	}

	a {
		text-decoration: none;
	}

	.icon {
		-webkit-user-select: none;
		display: inline-block;
	}

	.hidden {
		display: none;
	}


	/* Increase line height at higher resolutions. */
	@media (min-width: 641px) and (min-height: 641px) {
		#help-box-inner {
			line-height: 18px;
		}
	}

	/* Decrease padding at low sizes. */
	@media (max-width: 640px), (max-height: 640px) {
		h1 {
			margin: 0 0 15px;
		}

		#content-top {
			margin: 15px;
		}

		#help-box-inner {
			padding: 20px;
		}

		.suggestions {
			margin-top: 10px;
		}

		.suggestion-header {
			margin-bottom: 0;
		}
	}

	/* If the iframe is too small, always hide the error code. */
	/* TODO(mmenke): See if overflow: no-display works better, once supported. */
	@media (max-width: 200px), (max-height: 95px) {
		#sub-frame-error-details {
			display: none;
		}
	}

	/* Adjust icon for small embedded frames in apps. */
	@media (max-height: 100px) {
		#sub-frame-error .icon-generic {
			height: auto;
			margin: 0;
			padding-top: 0;
			width: 25px;
		}
	}

	/* details-button is special; it's a <button> element that looks like a link. */
	#details-button {
		box-shadow: none;
		min-width: 0;
	}

	/* Styles for platform dependent separation of controls and details button. */
	.suggested-left > #control-buttons,
	.suggested-right > #details-button {
		float: left;
	}

	.suggested-right > #control-buttons,
	.suggested-left > #details-button {
		float: right;
	}

	.suggested-left .secondary-button {
		margin-inline-end: 0px;
		margin-inline-start: 16px;
	}

	#details-button.singular {
		float: none;
	}

	#download-button:disabled {
		background: rgb(180, 206, 249);
		color: rgb(255, 255, 255);
	}

	/*
	TODO(https://crbug.com/852872): UI for offline suggested content is incomplete.
	*/
	.suggested-thumbnail {
		width: 25vw;
		height: 25vw;
	}

	/* Alternate dino page button styles */
	#control-buttons .reload-button-alternate:disabled {
		background: #ccc;
		color: #fff;
		font-size: 14px;
		height: 48px;
	}

	#buttons::after {
		clear: both;
		content: '';
		display: block;
		width: 100%;
	}

	/* Offline page */
	.offline {
		transition: filter 1.5s cubic-bezier(0.65, 0.05, 0.36, 1),
		background-color 1.5s cubic-bezier(0.65, 0.05, 0.36, 1);
		will-change: filter, background-color;
	}

	.offline body {
		transition: background-color 1.5s cubic-bezier(0.65, 0.05, 0.36, 1);
	}

	.offline #main-message > p {
		display: none;
	}

	/* iOS WKWebView inverts the background color set at the HTML level
	whereas Blink does not. */
	.offline.inverted {
		filter: invert(1);
		background-color: #000;
	}

	.offline.inverted body {
		background-color: #fff;
	}

	.offline .interstitial-wrapper {
		color: var(--text-color);
		font-size: 1em;
		line-height: 1.55;
		margin: 0 auto;
		max-width: 600px;
		padding-top: 100px;
		width: 100%;
	}

	.offline .runner-container {
		direction: ltr;
		height: 150px;
		max-width: 600px;
		overflow: hidden;
		position: absolute;
		top: 35px;
		width: 44px;
	}

	.offline .runner-canvas {
		height: 150px;
		max-width: 600px;
		opacity: 1;
		overflow: hidden;
		position: absolute;
		top: 0;
		z-index: 10;
	}

	.offline .controller {
		background: rgba(247, 247, 247, .1);
		height: 100vh;
		left: 0;
		position: absolute;
		top: 0;
		width: 100vw;
		z-index: 9;
	}

	#offline-resources {
		display: none;
	}

	#offline-instruction {
		image-rendering: pixelated;
		left: 0;
		margin: auto;
		position: absolute;
		right: 0;
		top: 60px;
		width: fit-content;
	}

	@media (max-width: 420px) {
		#download-button {
			padding-bottom: 12px;
			padding-top: 12px;
		}

		.suggested-left > #control-buttons,
		.suggested-right > #control-buttons {
			float: none;
		}

		.snackbar {
			left: 0;
			bottom: 0;
			width: 100%;
			border-radius: 0;
		}
	}

	@media (max-height: 350px) {
		h1 {
			margin: 0 0 15px;
		}

		.icon-offline {
			margin: 0 0 10px;
		}

		.interstitial-wrapper {
			margin-top: 5%;
		}

		.nav-wrapper {
			margin-top: 30px;
		}
	}

	@media (min-width: 420px) and (max-width: 736px) and
	(min-height: 240px) and (max-height: 420px) and
	(orientation: landscape) {
		.interstitial-wrapper {
			margin-bottom: 100px;
		}
	}

	@media (max-width: 360px) and (max-height: 480px) {
		.offline .interstitial-wrapper {
			padding-top: 60px;
		}

		.offline .runner-container {
			top: 8px;
		}
	}

	@media (min-height: 240px) and (orientation: landscape) {
		.offline .interstitial-wrapper {
			margin-bottom: 90px;
		}

		.icon-offline {
			margin-bottom: 20px;
		}
	}

	@media (max-height: 320px) and (orientation: landscape) {
		.icon-offline {
			margin-bottom: 0;
		}

		.offline .runner-container {
			top: 10px;
		}
	}

	@media (max-width: 240px) {
		button {
			padding-left: 12px;
			padding-right: 12px;
		}

		.interstitial-wrapper {
			overflow: inherit;
			padding: 0 8px;
		}
	}

	@media (max-width: 120px) {
		button {
			width: auto;
		}
	}

	.arcade-mode,
	.arcade-mode .runner-container,
	.arcade-mode .runner-canvas {
		image-rendering: pixelated;
		max-width: 100%;
		overflow: hidden;
	}

	.arcade-mode #buttons,
	.arcade-mode #main-content {
		opacity: 0;
		overflow: hidden;
	}

	.arcade-mode .interstitial-wrapper {
		height: 100vh;
		max-width: 100%;
		overflow: hidden;
	}

	.arcade-mode .runner-container {
		left: 0;
		margin: auto;
		right: 0;
		transform-origin: top center;
		transition: transform 250ms cubic-bezier(0.4, 0.0, 1, 1) .4s;
		z-index: 2;
	}

	@media (prefers-color-scheme: dark) {
		.icon {
			filter: invert(1);
		}

		.offline .runner-canvas {
			filter: invert(1);
		}

		.offline.inverted {
			filter: invert(0);
			background-color: #fff;
		}

		.offline.inverted body {
			background-color: #fff;
		}

		#suggestions-list a {
			color: var(--link-color);
		}

		#error-information-button {
			filter: invert(0.6);
		}
	}

	</style>
</head>

<body id="t">
<div class="interstitial-wrapper" id="main-frame-error">
	<div id="offline-resources">
		<img id="offline-resources-1x"
		     src="data:image/png;base64,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">
		<img id="offline-resources-2x"
		     src="data:image/png;base64,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">
		<template id="audio-resources">
			<audio id="offline-sound-press"
			       src="data:audio/mpeg;base64,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"></audio>
			<audio id="offline-sound-hit"
			       src="data:audio/mpeg;base64,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"></audio>
			<audio id="offline-sound-reached"
			       src="data:audio/mpeg;base64,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"></audio>
		</template>
	</div>

	<script type="text/javascript">
	new Runner('.interstitial-wrapper');

	</script>


</body>

</html>
